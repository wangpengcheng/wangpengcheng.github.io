<!DOCTYPE html>
<html lang="en">


<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="referrer" content="never">
<!--可以让img标签预加载网络图片-->
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Leaning and function with your new object.">
    <meta name="keywords" content="JF, JF Blog, 敬方的个人博客, OpenCV, 敬方, Qt, C++, 流媒体，计算机视觉，高性能计算">
    <meta name="theme-color" content="#000000">
    
    <title>go面经 - 敬方的个人博客 | JF Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">

    <!-- Safari Webpage Icon    by-BY -->
    <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://wangpengcheng.github.io//2023/04/17/go_interview/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="https://wangpengcheng.github.io//css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="https://wangpengcheng.github.io//css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="https://wangpengcheng.github.io//css/syntax.css" type="text/css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">My Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-ios10.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/post-bg-ios10.jpg')
    }

    
</style>
<header class="intro-header">
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91" title="后台开发">后台开发</a>
                        
                        <a class="tag" href="/tags/#%E9%9D%A2%E8%AF%95" title="面试">面试</a>
                        
                        <a class="tag" href="/tags/#go" title="go">go</a>
                        
                    </div>
                    <h1>go面经</h1>
                    
                    
                    <h2 class="subheading">go 语言常见面经汇总</h2>
                    
                    <span class="meta">Posted by 敬方 on April 17, 2023</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<h1 id="golang面试总结">Golang面试总结</h1>

<p><em>参考链接:</em></p>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/434629143">go语言常见面试题</a></li>
  <li><a href="https://www.zhihu.com/column/c_1212699838745346048">golang 快速入门</a></li>
  <li><a href="https://geektutu.com/post/qa-golang.html">Go 语言笔试面试题汇总</a></li>
  <li><a href="https://golang.design/go-questions/">GO 程序员面试笔试宝典</a></li>
  <li><a href="https://interview.apachecn.org/">Interview面试指南</a></li>
  <li><a href="https://github.com/lifei6671/interview-go">go面试题集合</a></li>
  <li><a href="https://github.com/shomali11/go-interview">go面试题</a></li>
  <li><a href="https://github.com/yqchilde/Golang-Interview">go面试题收集</a></li>
  <li><a href="https://github.com/go-share-team/go_interview">go面经</a></li>
  <li><a href="https://www.nowcoder.com/search/all?query=go%20%E9%9D%A2%E7%BB%8F&type=all&searchType=%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F">牛客go面经</a></li>
  <li><a href="https://codetop.cc/home">常见算法题总结</a></li>
  <li><a href="https://learn.lianglianglee.com/">技术摘抄</a></li>
  <li><a href="https://books.studygolang.com/GoExpertProgramming/">go专家编程</a></li>
  <li><a href="https://github.com/Tencent/secguide/blob/main/Go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md">Go安全指南</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1911268">Go 编码规范建议</a></li>
  <li><a href="https://geektutu.com/post/hpg-escape-analysis.html">Go语言高性能编程</a></li>
  <li><a href="https://draveness.me/golang/">Go语言设计与实现</a></li>
  <li><a href="https://golang.design/under-the-hood/">Go语言原本</a></li>
</ul>

<h2 id="基础语法">基础语法</h2>

<h3 id="go-的基础变量类型有哪些">go 的基础变量类型有哪些</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">类型分类</th>
      <th style="text-align: center">类型</th>
      <th style="text-align: center">默认值</th>
      <th style="text-align: center">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">布尔型</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td style="text-align: center">false</td>
      <td style="text-align: center">基础bool类型(一个字节)</td>
    </tr>
    <tr>
      <td style="text-align: center" rowspan="8">整数类型
<br><br><br><br><br><br><br>
</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">uint8</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">无符号8位整型(0~255)</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">uint16</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">无符号16位整型(0~65535)</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">uint32</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">无符号32位整型(0~4294967295)</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">uint64</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">无符号64位整型(0~18446744073709551615)</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">int8</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">有符号8位整型(-128~127)</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">int16</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">有符号16位整型(-32768~32767)</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">int32</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">有符号32位整型 (-2147483648~2147483647)</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">int64</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">有符号32位整型(-9223372036854775808~9223372036854775807)</td>
    </tr>
    <tr>
      <td style="text-align: center" rowspan="4">浮点类型
<br><br><br>
</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">float32</code></td>
      <td style="text-align: center">0.0</td>
      <td style="text-align: center">IEEE-754 32位浮点型数</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">float64</code></td>
      <td style="text-align: center">0.0</td>
      <td style="text-align: center">IEEE-754 64位浮点型数</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">complex64</code></td>
      <td style="text-align: center">0.0</td>
      <td style="text-align: center">32位实数和虚数</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">complex128</code></td>
      <td style="text-align: center">0.0</td>
      <td style="text-align: center">64 位实数和虚数</td>
    </tr>
    <tr>
      <td style="text-align: center" rowspan="5">其它数字类型
<br><br><br><br>
</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">byte</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">与uint8一致，一个字节8位</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">rune</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">char默认类型，与int32类似</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">int</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">有符号32/64整型，字节长度与操作系统类型一致</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">uint</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">无符号32/64整型，字节长度与操作系统类型一致</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">uintptr</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">与uint一致，用于存放指针地址</td>
    </tr>
    <tr>
      <td style="text-align: center" rowspan="7">派生类型
<br><br><br><br><br><br>
</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">pointer</code></td>
      <td style="text-align: center">nil</td>
      <td style="text-align: center">指针类型，用于指向对应的内存地址</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">[]T</code></td>
      <td style="text-align: center">nil</td>
      <td style="text-align: center">数组类型，用于进行数组存储</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">slice</code></td>
      <td style="text-align: center">nil</td>
      <td style="text-align: center">切片类型，用于进行go切片管理</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Channel</code></td>
      <td style="text-align: center">nil</td>
      <td style="text-align: center">管道，统一的消息管理</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">func</code></td>
      <td style="text-align: center">nil</td>
      <td style="text-align: center">函数，类似于c语言的函数指针</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">interface/any</code></td>
      <td style="text-align: center">nil</td>
      <td style="text-align: center">接口类型，类似于C++中的虚函数指针</td>
    </tr>
    <tr>
      
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">map</code></td>
      <td style="text-align: center">nil</td>
      <td style="text-align: center">map类型，hash map基础类型</td>
    </tr>
  </tbody>
</table>

<hr>

<ul>
  <li>参考:<a href="https://www.runoob.com/go/go-data-types.html">go语言基础类型</a>;<a href="https://fasionchan.com/golang/tour/basic-types/">go语言基本类型</a>;<a href="https://blog.csdn.net/FromTheWind/article/details/105862844">Golang中uint、int, int8, int16, int32, int64区别</a>
</li>
</ul>

<h3 id="01--和--的区别">01 = 和 := 的区别？</h3>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">=</code>:
    <ul>
      <li>语义不同：仅仅进行赋值，要求左侧对象必须已经声明</li>
      <li>使用语法：需要与<code class="language-plaintext highlighter-rouge">var</code>进行配合使用</li>
      <li>使用位置：可以用于函数中和函数外</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">:=</code>:
    <ul>
      <li>语义：声明+赋值，声明变量的同时进行自动赋值，中间涉及到自动推断</li>
      <li>语法：<strong>左侧必须有新的变量生成</strong>，否则会有语法错误</li>
      <li>使用位置：只能用于函数中，不能用于函数外</li>
    </ul>
  </li>
</ul>

<hr>

<ul>
  <li>参考: <a href="https://juejin.cn/post/6947897494059614215">Go语言学习之:=与=的区别</a>;<a href="https://zhuanlan.zhihu.com/p/115085755">golang快速入门[8.2]-自动类型推断的秘密</a>
</li>
</ul>

<h3 id="02-指针的作用">02 指针的作用</h3>

<ol>
  <li>保存变量地址，通过<code class="language-plaintext highlighter-rouge">&amp;</code> 与<code class="language-plaintext highlighter-rouge">*</code> 操作符间接访问内存地址，减少值传递损耗</li>
</ol>

<h3 id="03-go-允许多个返回值吗">03 Go 允许多个返回值吗？</h3>

<p>允许，同时允许命名返回值。命名后的返回值，相当于预定义变量。
返回值注意事项：</p>
<ul>
  <li>返回值不能用容器对象接收：只能用多个变量或者用<code class="language-plaintext highlighter-rouge">_</code> 忽略</li>
  <li>命名返回参数：可看做形参类似局部变量，最后由return 隐式返回</li>
  <li>局部变量遮蔽：命名返回参数可被同名局部变量遮蔽，此时需要显式返回</li>
  <li>defer作用：defer 函数作用在空return之前。返回值无命名是会生成不同的临时变量。避免异常</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">add1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">z</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span> <span class="c">// 不能在一个级别，引发 "z redeclared in this block" 错误。</span>
        <span class="k">var</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
        <span class="c">// return   // Error: z is shadowed during return</span>
        <span class="k">return</span> <span class="n">z</span> <span class="c">// 必须显式返回。</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">add2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">z</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">z</span><span class="o">++</span>
        <span class="nb">println</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="c">// 输出: 203</span>
    <span class="p">}()</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">z</span> <span class="o">+</span> <span class="m">200</span> <span class="c">// 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">add3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">z</span> <span class="o">:=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">z</span><span class="o">++</span>
        <span class="nb">println</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="c">// 输出: 204</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">z</span> <span class="o">+</span> <span class="m">200</span> <span class="c">// 执行顺序：(s = z + 200) -&gt; (call defer) -&gt; (return )</span>
<span class="p">}</span>


<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="n">add1</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">))</span> <span class="c">// 输出：3</span>
    <span class="nb">println</span><span class="p">(</span><span class="n">add2</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">))</span> <span class="c">// 输出: 204</span>
    <span class="nb">println</span><span class="p">(</span><span class="n">add3</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">))</span> <span class="c">// 输出: 203</span>
<span class="p">}</span>
</code></pre></div></div>
<hr>

<ul>
  <li>参考：<a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E8%BF%94%E5%9B%9E%E5%80%BC.html">go返回值</a>
</li>
</ul>

<h3 id="04-go-有异常类型吗">04 Go 有异常类型吗？</h3>
<p>go 没有异常类型，只有错误类型，通常用返回值来表示异常状态</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="05-什么是协程goroutine">05 什么是协程（Goroutine）</h3>

<p>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p>

<hr>

<p>参考：<a href="https://wangpengcheng.github.io/2019/12/17/baidu_interview_prepare/#418-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%8F%E7%A8%8B">说一说协程</a>;<a href="https://wangpengcheng.github.io/2019/12/17/baidu_interview_prepare/#418-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%8F%E7%A8%8B">协程与线程区别</a></p>

<h3 id="06-如何高效地拼接字符串">06 如何高效地拼接字符串</h3>
<p>Go语言中，字符串是只读的，每次修改操作都会创建一个新的字符串(与java类似)，如果需要拼接多次，使用strings.Builder，最小化内存拷贝次数</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">str</span> <span class="n">strings</span><span class="o">.</span><span class="n">Builder</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="n">str</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">str</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>
</code></pre></div></div>

<hr>

<ul>
  <li>参考：<a href="https://blog.51cto.com/yuzhou1su/5268459">深入理解 Go 中的字符串</a>;<a href="https://blog.csdn.net/sinat_31862487/article/details/134044392">深入理解Go语言的string 类型</a>;<a href="https://segmentfault.com/a/1190000040023113">你不知道的Go 之string</a>
</li>
</ul>

<h3 id="07-什么是-rune-类型">07 什么是 rune 类型</h3>
<p>go 语言中rune是unicode 编码代称，是int32的别名，string 可以转换为rune数组。
但是字符串的底层是byte(8 bit)序列，而非rune(32bit)。如下：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="s">`Go语言`</span>
    <span class="c">// 这里string底层为byte，`语言`为utf-8编码因此使用6个字节</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="c">// 8</span>
    <span class="c">// 这里转换为rune数组，每个字符都是一个rune，长度为4，内存为16字节</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">([]</span><span class="kt">rune</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span> <span class="c">// 4</span>
    <span class="c">// 输出内存中第3个字节内容，长度为1字节</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">])</span> <span class="c">// 232</span>
    <span class="c">// 输出第二个rune内容，长度为4字节</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">([]</span><span class="kt">rune</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="m">2</span><span class="p">])</span> <span class="c">// 35821</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello W3Cschool!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>注意：
    <ul>
      <li>字符串遍历<strong>通过下标索引字符串将会产生一个字节</strong>,字符串中含有UTF-8编码字符时，会出现乱码</li>
      <li>使用range 遍历：会将字符串转换为rune类型</li>
    </ul>
  </li>
</ul>

<hr>

<p>参考:<a href="https://zhuanlan.zhihu.com/p/93052559">Go 语言中的字符与字符串遍历</a>;<a href="https://segmentfault.com/a/1190000040023113">你不知道的Go之string</a></p>

<h3 id="08-如何判断-map-中是否包含某个-key-">08 如何判断 map 中是否包含某个 key ？</h3>
<ul>
  <li>普通情况下： 在map不为<code class="language-plaintext highlighter-rouge">nil</code> 的情况下，直接根据key取值第二个，检查是否存在即可，如下：
    <div class="language-go highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">val</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">dict</span><span class="p">[</span><span class="s">"foo"</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
  <span class="c">//do something here</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>高并发情况下：原始map并非并发安全，高并发情况下，应该使用读写锁/分片锁/sync.map(仅仅适用于一写多读情况)</li>
</ul>

<hr>

<p>参考：<a href="https://zhuanlan.zhihu.com/p/356739568">Go并发之三种线程安全的map</a>;<a href="https://developer.aliyun.com/article/1172753">Golang sync.Map原理（两个map实现 读写分离、适用读多写少场景）</a></p>

<h3 id="09-go支持默认参数或可选参数吗">09 Go支持默认参数或可选参数吗？</h3>
<ul>
  <li>不支持：GO不支持可选参数和默认参数，也不支持方法重载。可以通过struct的方式，添加默认参数。支持可变参数，可以通过可变参数判断，间接实现参数可选</li>
  <li>间接支持：
    <ul>
      <li>可用通过struct配合反射实现可变参数的间接支持</li>
      <li>通过选择器模式与适配器模式实现可变参数的间接支持</li>
    </ul>
  </li>
</ul>

<hr>

<p>参考: <a href="https://cloud.tencent.com/developer/article/2025794">golang中函数如何设置参数默认值</a>;<a href="https://www.zhihu.com/question/24368980">golang函数中的参数为什么不支持默认值?-知乎</a>;<a href="https://www.cnblogs.com/smartrui/p/10324320.html">Golang中设置函数默认参数的优雅实现</a></p>

<h3 id="10-defer-的执行顺序">10 defer 的执行顺序</h3>
<ul>
  <li>多个defer 后进先出：多个defer遵循后进先出的原则，最后声明的最先得到执行</li>
  <li>已代码块为分界点：代码块中defer作用在代码块上下文中</li>
  <li>defer 在return之后，函数退出之前执行：将<code class="language-plaintext highlighter-rouge">return i</code> 拆分为<code class="language-plaintext highlighter-rouge">s=i; return </code>两个语句分析接口</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">test</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>

    <span class="p">{</span>
        <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"defer0"</span><span class="p">)</span>    
        <span class="p">}()</span>
    <span class="p">}</span>

	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"defer1"</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="m">1</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"defer2"</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span>


<span class="k">func</span> <span class="n">test1</span><span class="p">()</span> <span class="p">(</span><span class="n">i</span>  <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="m">0</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="m">1</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"defer4"</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"return"</span><span class="p">,</span> <span class="n">test</span><span class="p">())</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"return"</span><span class="p">,</span> <span class="n">test1</span><span class="p">())</span>
<span class="p">}</span>
<span class="c">// defer0</span>
<span class="c">// defer2</span>
<span class="c">// defer1</span>
<span class="c">// return 0</span>
<span class="c">// defer4</span>
<span class="c">// return 1</span>
</code></pre></div></div>
<hr>

<ul>
  <li>参考：<a href="https://juejin.cn/post/7095631673865273352">Golang的defer与return的执行顺序</a>
</li>
</ul>

<h3 id="11-如何交换-2-个变量的值">11 如何交换 2 个变量的值？</h3>

<p>go 中无swap函数，也不像java交换复杂(需要借助临时变量)，直接交换即可。如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="s">"A"</span><span class="p">,</span> <span class="s">"B"</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c">// B A</span>
</code></pre></div></div>

<h3 id="12-go-语言-tag-的用处">12 Go 语言 tag 的用处？</h3>

<p>本质：tag的本质是struct字段注解：用于定义字段的一个或者多个属性，通过反射获取tag进行解析
由本质衍生了如下作用：</p>
<ul>
  <li>序列化和反序列化：通过标签控制字段与输出值的映射，控制其序列化与反序列化，如json转换：通过<code class="language-plaintext highlighter-rouge">json:"xxx"</code>定义结构体字段与json字段的转换关系</li>
  <li>数据验证：通过标签中的<code class="language-plaintext highlighter-rouge">default</code> 进行字段值的验证和添加</li>
  <li>数据库 ORM 映射： 有些数据库 ORM（对象关系映射）库允许你使用标签来定义数据库表和结构体之间的映射关系</li>
  <li>HTTP 路由和处理： 在某些 Web 框架中，标签可以被用来定义 HTTP 路由规则或者请求处理逻辑</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"reflect"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">User</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span> <span class="s">`json:"name" mytag:"myName"`</span>
	<span class="n">Age</span>  <span class="kt">int</span>    <span class="s">`json:"age" mytag:"myAge"`</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">user</span> <span class="o">:=</span> <span class="n">User</span><span class="p">{</span><span class="s">"Bob"</span><span class="p">,</span> <span class="m">30</span><span class="p">}</span>
	<span class="c">// 获取值反射</span>
	<span class="n">v</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
	<span class="c">// 获取类型</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">Type</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="n">NumField</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c">// 字段</span>
		<span class="n">field</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="c">// 输出字段和值</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">Tag</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"json"</span><span class="p">),</span> <span class="n">field</span><span class="o">.</span><span class="n">Tag</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"mytag"</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">FieldByName</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">Name</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 输出：</span>
<span class="c">// Name name myName Bob</span>
<span class="c">// Age age myAge 30</span>

</code></pre></div></div>
<hr>

<ul>
  <li>参考：<a href="https://learnku.com/articles/78000">GoTag标签</a>
</li>
</ul>

<h3 id="13-如何判断-2-个字符串切片slice-是相等的">13 如何判断 2 个字符串切片(slice) 是相等的？</h3>
<p>不能直接使用<code class="language-plaintext highlighter-rouge">==</code> 这样只能说明两个slice指向同一个底层数组</p>

<ul>
  <li>反射比较：直接使用反射reflect.DeepEqual(a, b) 判断 a、b两个切片是否相等。但是性能较低</li>
  <li>直接比较：遍历比较切片中的每一个元素（注意处理越界的情况），性能较好</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">StringSliceEqualBCE</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">false</span>
    <span class="p">}</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">a</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">return</span> <span class="no">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>
</code></pre></div></div>
<hr>

<ul>
  <li>参考: <a href="https://zhuanlan.zhihu.com/p/615613789">Golang中如何判断两个slice是否相等？</a>;<a href="https://darjun.github.io/2021/05/09/youdontknowgo/slice/">你不知道的Go之slice</a>
</li>
</ul>

<h3 id="14-字符串打印时v-和-v-的区别">14 字符串打印时，%v 和 %+v 的区别</h3>
<p>%v 和 %+v 都可以用来打印 struct 的值，区别在于 %v 仅打印各个字段的值，%+v 还会打印各个字段的名称。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Stu</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Stu</span><span class="p">{</span><span class="s">"Tom"</span><span class="p">})</span> <span class="c">// {Tom}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Stu</span><span class="p">{</span><span class="s">"Tom"</span><span class="p">})</span> <span class="c">// {Name:Tom}</span>
<span class="p">}</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: center">格式</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%v</code></td>
      <td style="text-align: left">按值的本来值输出</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%+v</code></td>
      <td style="text-align: left">在 %v 基础上，对结构体字段名和值进行展开</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%#v</code></td>
      <td style="text-align: left">输出 Go 语言语法格式的值</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%T</code></td>
      <td style="text-align: left">输出 Go 语言语法格式的类型和值</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%%</code></td>
      <td style="text-align: left">输出 % 本体</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%b</code></td>
      <td style="text-align: left">整型以二进制方式显示</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%o</code></td>
      <td style="text-align: left">整型以八进制方式显示</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%d</code></td>
      <td style="text-align: left">整型以十进制方式显示</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%x</code></td>
      <td style="text-align: left">整型以十六进制方式显示</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%X</code></td>
      <td style="text-align: left">整型以十六进制、字母大写方式显示</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%U</code></td>
      <td style="text-align: left">Unicode 字符</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%f</code></td>
      <td style="text-align: left">浮点数,如<code class="language-plaintext highlighter-rouge">%6.2f</code>，指定整数与小数位长度</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%p</code></td>
      <td style="text-align: left">指针，十六进制方式显示</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%s</code></td>
      <td style="text-align: left">字符串，指定字符串输出，<code class="language-plaintext highlighter-rouge">%10s</code>/<code class="language-plaintext highlighter-rouge">%-10s</code>，宽度为10左/右对齐</td>
    </tr>
  </tbody>
</table>

<hr>

<ul>
  <li>参考：<a href="https://www.runoob.com/go/go-fmt-sprintf.html">Gofmt.Sprintf格式化字符串</a>;<a href="https://studygolang.com/articles/17400">深入理解fmt包</a>
</li>
</ul>

<h3 id="15-go-语言中如何表示枚举值enums">15 Go 语言中如何表示枚举值(enums)？</h3>

<p>使用const 常量来表示枚举值 <code class="language-plaintext highlighter-rouge">iota</code> 表示0</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">StuType</span> <span class="kt">int32</span>

<span class="k">const</span> <span class="p">(</span>
	<span class="n">Type1</span> <span class="n">StuType</span> <span class="o">=</span> <span class="no">iota</span>
	<span class="n">Type2</span>
	<span class="n">Type3</span>
	<span class="n">Type4</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Type1</span><span class="p">,</span> <span class="n">Type2</span><span class="p">,</span> <span class="n">Type3</span><span class="p">,</span> <span class="n">Type4</span><span class="p">)</span> <span class="c">// 0, 1, 2, 3</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="16-空-struct-的用途">16 空 struct{} 的用途</h3>
<p>主要用于占位符号，表明这里并不需要一个值，来进行内存节省。主要用于以下场景</p>
<ol>
  <li>map中value占位符，用于表示set</li>
  <li>管道(channel)中占位符，仅仅表示信号</li>
  <li>基础工具类：仅仅用于继承接口声明方法</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span> 

<span class="c">// 1. 输出值</span>
<span class="k">func</span> <span class="n">PrintTest</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Sizeof</span><span class="p">(</span><span class="k">struct</span><span class="p">{}{}))</span> <span class="c">// 0</span>
<span class="p">}</span>

<span class="c">// 2. 构造set</span>
<span class="k">type</span> <span class="n">Set</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="n">SetTest</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">set</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="n">Set</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"A"</span><span class="p">,</span> <span class="s">"A"</span><span class="p">,</span> <span class="s">"B"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">}</span> <span class="p">{</span>
		<span class="n">set</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="k">struct</span><span class="p">{}{}</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set</span><span class="p">))</span> <span class="c">// 3</span>
	<span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">set</span><span class="p">[</span><span class="s">"A"</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"A exists"</span><span class="p">)</span> <span class="c">// A exists</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 3. 使用管道</span>
<span class="k">func</span> <span class="n">ChannelTest</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{},</span> <span class="m">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="n">ch</span>
		<span class="c">// do something</span>
	<span class="p">}()</span>
	<span class="n">ch</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
<span class="p">}</span>

<span class="c">// 4. 声明方法继承</span>
<span class="k">type</span> <span class="n">Lamp</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="n">Lamp</span><span class="p">)</span> <span class="n">On</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">println</span><span class="p">(</span><span class="s">"On"</span><span class="p">)</span>

<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="n">Lamp</span><span class="p">)</span> <span class="n">Off</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">println</span><span class="p">(</span><span class="s">"Off"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PrintTest</span><span class="p">()</span>
    <span class="n">SetTest</span><span class="p">()</span>
    <span class="n">ChannelTest</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现原理">实现原理</h2>
<h3 id="01-init-函数是什么时候执行的">01 init() 函数是什么时候执行的？</h3>
<ul>
  <li>init 与man函数一样，不能有入参与返回值</li>
  <li>init 函数由runtime初始化每个包的导入，按照解析的依赖关系，没有依赖的包最先初始化</li>
  <li>包初始化顺序： 包作用域常量-&gt; 包作用域变量-&gt; 包内init()函数。即<code class="language-plaintext highlighter-rouge">import –&gt; const –&gt; var –&gt; init() –&gt; main()</code>
</li>
  <li>同包内多个<code class="language-plaintext highlighter-rouge">init()</code>：按照它们呈现给编译器的顺序被调用
    <ul>
      <li>同文件内：按照函数顺序进行调用</li>
      <li>同包不同源文件：是根据文件名的字典序来确定</li>
    </ul>
  </li>
  <li>不同包：
    <ul>
      <li>无相互依赖：按照main 包中import的顺序调用其包中的init函数</li>
      <li>存在依赖：调用顺序为最后被依赖的最先被初始化，如导入顺序<code class="language-plaintext highlighter-rouge">main &gt; a &gt; b &gt;c</code>, 初始化顺序<code class="language-plaintext highlighter-rouge">c &gt; b &gt; a &gt; main</code>
</li>
    </ul>
  </li>
  <li>使用建议：应当尽量避免使用<code class="language-plaintext highlighter-rouge">init()</code>，避免<code class="language-plaintext highlighter-rouge">init</code> 依赖其他顺序。</li>
</ul>

<p><img src="https://cdn.learnku.com/uploads/images/202007/13/1/hVMYyqi6EU.png!large" alt=""></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// a 包</span>
<span class="c">// a.go</span>
<span class="k">package</span> <span class="n">a</span>

<span class="k">import</span> <span class="n">_</span> <span class="s">"main/b"</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">"init a"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// b 包</span>
<span class="c">// b.go</span>
<span class="k">package</span> <span class="n">b</span>

<span class="k">import</span> <span class="n">_</span> <span class="s">"main/c"</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">"init b"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// c 包</span>
<span class="c">// c.go</span>
<span class="k">package</span> <span class="n">c</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">"init c"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// main 包</span>
<span class="c">// main.go</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="n">_</span> <span class="s">"main/a"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">"init main"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">"main"</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>
<p>对应输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go build <span class="o">&amp;&amp;</span> ./main
init c
init b
init a
init main
main
</code></pre></div></div>

<hr>

<ul>
  <li>参考：<a href="https://learnku.com/go/t/47135">一张图了解 Go 语言中的 init () 执行顺序
</a>;<a href="https://cloud.tencent.com/developer/article/2138066">一文读懂Golang init函数执行顺序</a>
</li>
</ul>

<h3 id="02-go-语言的局部变量分配在栈上还是堆上">02 Go 语言的局部变量分配在栈上还是堆上？</h3>

<p>由编译器决定。编译器经过逃逸分析，发现变量作用域未超出函数范围时，分配在栈上。反之必须分配在堆上。可以使用<code class="language-plaintext highlighter-rouge">-gcflags=-m</code> 编译参数，查看逃逸分析</p>

<p>关键在于go的逃逸分析，go 逃逸(堆上分配)原则如下：</p>
<ol>
  <li>指针逃逸：函数返回对象指针时，内存分配在堆上</li>
  <li>
<code class="language-plaintext highlighter-rouge">interface{}</code>动态类型逃逸：interface{}为指针别名，也会发生逃逸</li>
  <li>栈空间不足：栈使用超过操作系统内核线程栈限制(64位通常为8M,可以用<code class="language-plaintext highlighter-rouge">ulimit -a</code>查看)或者切片长度无法确定时，将存在逃逸</li>
  <li>闭包：闭包中内层函数会访问外层函数作用域。访问的外部变量会逃逸</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 1. 返回指针逃逸</span>
<span class="c">// d 在堆上分配内存</span>
<span class="k">func</span> <span class="n">createDemo</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">Demo</span> <span class="p">{</span>
	<span class="n">d</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Demo</span><span class="p">)</span> <span class="c">// 局部变量 d 逃逸到堆</span>
	<span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
	<span class="k">return</span> <span class="n">d</span>
<span class="p">}</span>

<span class="c">// 2. interface 逃逸</span>
<span class="c">// 局部变量demo 不会发生逃逸，但是demo.name 会逃逸</span>
<span class="k">func</span> <span class="n">test</span><span class="p">(</span><span class="n">demo</span> <span class="o">*</span><span class="n">Demo</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">demo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 3. 内存不足逃逸</span>
<span class="c">// 3.1 超过64KB发生逃逸</span>
<span class="k">func</span> <span class="n">generate8192</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">nums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">8192</span><span class="p">)</span> <span class="c">// = 64KB</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">8192</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="n">Int</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c">// 3.2 不确定大小逃逸</span>
<span class="k">func</span> <span class="n">generate</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">nums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="c">// 不确定大小</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="n">Int</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 4. 闭包逃逸</span>
<span class="c">// Increase() 返回值是一个闭包函数</span>
<span class="c">// 函数访问了外部变量n,n会一直存在直到in 被销毁</span>
<span class="k">func</span> <span class="n">IncreaseTest</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">in</span> <span class="o">:=</span> <span class="n">Increase</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">in</span><span class="p">())</span> <span class="c">// 1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Increase</span><span class="p">()</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="n">n</span><span class="o">++</span>
		<span class="k">return</span> <span class="n">n</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>使用建议：</p>
<ul>
  <li>指针传递增加逃逸负担：传值会拷贝整个对象，而指针只会拷贝指针地址，对应的对象一直是同一个，传指针可以有效减少值的拷贝。但是会导致内存分配逃逸到堆中，增加GC负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。
    <ul>
      <li><strong>对于需要修改原对象值，或占用内存比较大的结构体，选择传指针</strong></li>
      <li><strong>只读的占用内存较小的结构体，直接传值能够获得更好的性能</strong></li>
    </ul>
  </li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">go内存管理</a>;<a href="https://geektutu.com/post/hpg-escape-analysis.html">Go逃逸分析</a>;<a href="https://zhuanlan.zhihu.com/p/523215127">10分钟掌握golang内存管理机制</a>
</li>
</ul>

<h3 id="03-2-个-interface-可以比较吗">03 2 个 interface 可以比较吗？</h3>
<ul>
  <li>可以：go interface 内部实现包含了类型<code class="language-plaintext highlighter-rouge">T</code> 和值<code class="language-plaintext highlighter-rouge">v</code>。可进行比较，相等时存在如下情况
    <ol>
      <li>均为nil(v和T都处于unset状态)</li>
      <li>类型相同，并且对应的值相等
interface底层使用2个struct表示的：eface和iface，其实际类型定义如下：</li>
    </ol>
  </li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// runtime/runtime2.go</span>
<span class="c">// 空数据类型指针--不带方法</span>
<span class="k">type</span> <span class="n">eface</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">_type</span> <span class="o">*</span><span class="n">_type</span>  <span class="c">// 类型指针</span>
	<span class="n">data</span>  <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// 数据值指针</span>
<span class="p">}</span>

<span class="c">// runtime/runtime2.go</span>
<span class="c">// 非空接口--带方法</span>
<span class="k">type</span> <span class="n">iface</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">tab</span>  <span class="o">*</span><span class="n">itab</span>          <span class="c">// 对应的虚拟函数表</span>
    <span class="n">data</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">//指向原始数据指针</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">type</span> <span class="n">TestStruct</span> <span class="k">struct</span><span class="p">{}</span>

<span class="c">// Go 语言的接口类型不是任意类型</span>
<span class="c">// 这里进行了类型转换，将类型转换为了*TestStruct类型</span>
<span class="c">// 包含了*TestStruct的类型信息</span>
<span class="k">func</span> <span class="n">NilOrNot</span><span class="p">(</span><span class="n">v</span> <span class="k">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">v</span> <span class="o">==</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">s</span> <span class="o">*</span><span class="n">TestStruct</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span>      <span class="c">// #=&gt; true</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">NilOrNot</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>   <span class="c">// #=&gt; false</span>
<span class="p">}</span>

<span class="err">$</span> <span class="k">go</span> <span class="n">run</span> <span class="n">main</span><span class="o">.</span><span class="k">go</span>
<span class="no">true</span>
<span class="no">false</span>
</code></pre></div></div>

<hr>

<ul>
  <li>参考: <a href="https://www.cnblogs.com/jiujuan/p/12653806.html">深入理解Go语言(01): interface源码分析</a>;<a href="https://github.com/friendlyhank/toBeTopgopher/blob/master/golang/source/golang%E4%B9%8Binterface%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">golang之interface接口源码解析</a>;<a href="https://github.com/friendlyhank/toBeTopgopher/blob/master/golang/source/golang%E4%B9%8Binterface%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">go语言接口</a>
</li>
</ul>

<h3 id="04-2-个-nil-可能不相等吗">04 2 个 nil 可能不相等吗？</h3>

<p>可能: 类型值不同时，可能不相等</p>
<ul>
  <li>nil指针含义：接口(interface) 是对非接口值(指针/struct等)的封装，内部实现包含<code class="language-plaintext highlighter-rouge">T</code> 和<code class="language-plaintext highlighter-rouge">v</code>。一个接口为nil，仅仅表明<code class="language-plaintext highlighter-rouge">T</code>/<code class="language-plaintext highlighter-rouge">V</code> 都处于<code class="language-plaintext highlighter-rouge">unset</code> 状态(<code class="language-plaintext highlighter-rouge">T=nil, V = unset</code>)。</li>
  <li>接口值比较：先比较<code class="language-plaintext highlighter-rouge">T</code>, 再比较<code class="language-plaintext highlighter-rouge">V</code>
</li>
  <li>接口值与非接口值比较：将非接口值转换为接口值，再进行比较</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="k">type</span> <span class="n">MyInterface</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">MyType</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">mt</span> <span class="o">*</span><span class="n">MyType</span><span class="p">)</span> <span class="n">DoSomething</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">func</span> <span class="n">test2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="n">MyInterface</span>
    <span class="k">var</span> <span class="n">t</span> <span class="o">*</span><span class="n">MyType</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span>  <span class="c">// 输出：true</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span>  <span class="c">// 输出：true</span>
 	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>  <span class="c">// 输出：false</span>
	
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span>  <span class="c">// 输出：false</span>
<span class="p">}</span>



<span class="k">func</span> <span class="n">test1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">p</span> <span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="no">nil</span> 
    <span class="c">// 此时i 中的T = *int, V= nil</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="n">p</span>
    <span class="c">// 类型相同与值相同--相等</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="c">// true</span>
    <span class="c">// p 值为nil--相等</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span> <span class="c">// true</span>
	<span class="c">// 将nil 转换为接口(T=nil, V=nil), i T值不相同--不相等</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span> <span class="c">// false -- i 存在类型值</span>
<span class="p">}</span>

</code></pre></div></div>

<hr>

<ul>
  <li>参考：<a href="https://www.iamshuaidi.com/23121.html">在Golang中,两个nil可能不相等吗？</a>;</li>
</ul>

<h3 id="05-简述-go-语言gc垃圾回收的工作原理">05 简述 Go 语言GC(垃圾回收)的工作原理</h3>

<p>常见的垃圾回收算法有<strong>标记清除(Mark-Sweep)</strong>和<strong>引用计数(Reference Count)(如c++ share_ptr)</strong>，GO语言采用标记清除算法，同时为了提高效率保证准确性，使用了三色标记法和写屏障技术。</p>

<p>标记清除法分为如下两个阶段：</p>
<ul>
  <li>标记(Mark)阶段：从根对象出发，查找并标记堆中所有存活的对象。需要使用<strong>暂停程序(Stop The World, STW)</strong>
</li>
  <li>清除(Sweep)阶段：遍历堆中的全部对象，回收未标记的垃圾对象并将回收的内存加入空闲链表
Go 为了能够异步执行，减少STW时间，采用了三色标记法。通过三色标记算法降低标记的需要时间。主要是将算法程序中的对象分为黑、白、灰三类，只有白色会被清除：</li>
  <li>白色：不确定对象–可以清除</li>
  <li>灰色：存活对象，子对象需要进一步处理</li>
  <li>黑色：存活对象</li>
</ul>

<p>主要清除标记流程如下：</p>

<ol>
  <li>程序初始化：初始状态下，所有对象加入白色集合(需要STW)，将<strong>根对象(指赋值器不需要通过其他对象就可以直接访问到的对象,如全局变量/协程执行栈)</strong>标记为灰色。</li>
  <li>颜色扫描：从灰色独享集合中取出(ROOT)对象开始扫描
    <ul>
      <li>a. 将直接可达的对象标记为灰色</li>
      <li>a. 将取出对象标记为黑色</li>
      <li>b. 将其指向的所有对象标记为灰色</li>
      <li>c. 重复上述步骤，直到无灰色对象</li>
    </ul>
  </li>
  <li>对象清除：清除白色对象</li>
</ol>

<p><img src="https://data.eolink.com/2022-01-14/1642152085-909098-image.png" alt="初始三色标记法"></p>

<p>但是三色标记法强依赖 STW(性能较差)， 否则标记阶段程序的逻辑改变对象引用关系,会影响标记结果的正确性，可能会出现如下情况：</p>

<p><img src="https://data.eolink.com/2022-01-14/1642152123-524607-image.png" alt="非STW 三色标记异常"></p>

<p>为了优化性能，尽量减少STW使用，Golang 对三色标记法进行了优化。
上面的标记异常问题出现，存在两个条件</p>
<ol>
  <li><strong>白色对象被黑色对象引用</strong></li>
  <li><strong>灰色对象与白色对象之间的可达关系遭到破坏</strong></li>
</ol>

<p>只要上述条件任意破坏一下，就可以保证对象不丢失。由此提出了破坏方式：</p>
<ol>
  <li>
<strong>强三色不变式：</strong> 不允许黑色对象引用白色对象–破坏条件一</li>
  <li>
<strong>弱三色不变式：</strong> 黑色对象可以引用白色对象，但是白色对象的上游必须存在灰色对象–保证白色对象一定可以被扫描到</li>
</ol>

<p>为了尝试保证上述两点，有如下方式，详细操作流程如下：</p>

<ul>
  <li>
<strong>插入写屏障</strong>(强三色)：当一个对象引用另外一个对象时，将另外一个对象标记为灰色。
    <ul>
      <li><img src="https://data.eolink.com/2022-01-14/1642152399-611837-image.png" alt="总体机制"></li>
      <li>由于栈上对象没有插入写机制，在扫描完成后需要对栈上空间进行STW，防止对象错误删除。如下：</li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152399-611837-image.png" alt=""></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152408-446949-image.png" alt=""></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152415-201031-image.png" alt=""></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152430-572346-image.png" alt=""></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152437-364823-image.png" alt=""></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152443-909009-image.png" alt=""></li>
      <li>
<strong>缺点：</strong> 栈上对象无法操作, 需要对栈空间进行stw保护，然后rescan保证引用的白色对象存活。增加了GC时间</li>
    </ul>
  </li>
  <li>
<strong>删除写屏障</strong>(弱三色)：在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。
    <ul>
      <li><img src="https://data.eolink.com/2022-01-14/1642152473-725532-image.png" alt="删除写屏障"></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152478-737731-image.png" alt="删除写屏障2"></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152483-907048-image.png" alt="删除写屏障3"></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152488-972239-image.png" alt="删除写屏障4"></li>
      <li>
<strong>缺点：</strong> 中间变更的无引用对象，会被保留，存活到下一轮，降低了回收精度
        <ul>
          <li><a href="https://data.eolink.com/2022-01-14/1642152499-445418-image.png">删除机制</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>混合写屏障机制(v1.8)</strong>：栈上可达对象全部标黑(避免栈引用丢失)，堆上删除/添加对象标记为灰色。具体步骤如下
    <ul>
      <li>GC刚开始的时候，会将栈上的可达对象全部标记为黑色。</li>
      <li>GC期间，任何在栈上新创建的对象，均为黑色。</li>
      <li>堆上被删除的对象标记为灰色</li>
      <li>堆上新添加的对象标记为灰色</li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152627-900304-image.png" alt="流程图1"></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152632-450577-image.png" alt="流程图2"></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152638-980225-image.png" alt="流程图3"></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152643-404267-image.png" alt="流程图4"></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152647-868470-image.png" alt="流程图5"></li>
      <li><img src="https://data.eolink.com/2022-01-14/1642152652-807003-image.png" alt="流程图6"></li>
    </ul>
  </li>
</ul>

<p>最终go 使用<strong>插入写机制</strong>，在用户程序读取对象、创建新对象以及更新对象时，执行一段临界区代码(内存屏障)。当对象新增或者更新时，将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p>

<ul>
  <li>总结，
    <ul>
      <li>完整GC阶段如下：
        <ul>
          <li>1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</li>
          <li>2）使用三色标记法标记（Marking, 并发）</li>
          <li>3）标记结束(Mark Termination，需 STW)，关闭写屏障。</li>
          <li>4）清理(Sweeping, 并发)</li>
        </ul>
      </li>
      <li>版本演进：
        <ul>
          <li>v1.3：采用传统采取标记-清除法，需要STW，暂停整个程序的运行。</li>
          <li>v1.5：引入了三色标记法和插入写屏障机制，其中插入写屏障机制只在堆内存中生效。但在标记过程中，最后需要对栈进行STW。</li>
          <li>v1.8：结合删除写屏障机制，推出了混合屏障机制，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">go垃圾收集器</a>;<a href="https://community.apinto.com/d/34057-golang-gc">一文弄懂 Golang GC、三色标记、混合写屏障机制</a>
</li>
</ul>

<h3 id="06-函数返回局部变量的指针是否安全">06 函数返回局部变量的指针是否安全？</h3>

<p>安全：Golang 会对每个变量进行逃逸分析，发现其作用域超出函数时，会直接在堆上分配内存</p>

<h3 id="07-非接口的任意类型-t-都能够调用-t-的方法吗反过来呢">07 非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？</h3>
<ul>
  <li>
<strong><code class="language-plaintext highlighter-rouge">T()</code>调用<code class="language-plaintext highlighter-rouge">*T</code>仅仅在T可寻址的情况下成立</strong>：编译器在调用指针属主方法之前，会自动取此T值的地址。因为不是每个T都可以进行寻址，所以并非任何T值都能够调用为类型*T声明的方法。存在如下情况(编译前确定的值)时不可寻址
    <ul>
      <li>字符串中的字节</li>
      <li>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）</li>
      <li>常量</li>
      <li>包级别的函数</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">*T</code> 类型的值<strong>可以调用</strong><code class="language-plaintext highlighter-rouge">T</code>声明方法：
    <ul>
      <li>因为解引用指针总是合法的。</li>
      <li>每一个类型<code class="language-plaintext highlighter-rouge">T</code> 声明的方法，编译器都会为类型<code class="language-plaintext highlighter-rouge">*T</code> 自动隐式声明一个同名和同签名的方法。</li>
    </ul>
  </li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="kt">string</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">t1</span> <span class="n">T</span> <span class="o">=</span> <span class="s">"ABC"</span>
	<span class="n">t1</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span> <span class="c">// hello</span>
    <span class="c">// t2 为常量--非*T 类型</span>
	<span class="k">const</span> <span class="n">t2</span> <span class="n">T</span> <span class="o">=</span> <span class="s">"ABC"</span>
	<span class="n">t2</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span> <span class="c">// error: cannot call pointer method on t</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="并发编程">并发编程</h2>

<h3 id="01-无缓冲的-channel-和有缓冲的-channel-的区别">01 无缓冲的 channel 和有缓冲的 channel 的区别？</h3>
<ul>
  <li>无缓冲channel: 发送方将阻塞该信道，直到接收方从该信道收到数据为止，接收方同样需要阻塞该信号，直到发送方将数据发送到该信道中为止</li>
  <li>有缓冲channel: 信号再存在缓冲中，在缓冲区用尽的情况下阻塞</li>
</ul>

<p>可以用于进行协程交替打印字符串</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
<span class="n">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>

<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="m">2</span> <span class="p">{</span>
      <span class="o">&lt;-</span><span class="n">ch1</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">ch2</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
   <span class="p">}</span>
   <span class="o">&lt;-</span><span class="n">ch1</span>
<span class="p">}()</span>

<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="m">2</span> <span class="p">{</span>
      <span class="o">&lt;-</span><span class="n">ch2</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">ch1</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
<span class="p">}</span>

<span class="n">ch1</span> <span class="o">&lt;-</span> <span class="k">struct</span><span class="p">{}{}</span>
<span class="c">// 等待协程执行完毕</span>
<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
</code></pre></div></div>

<hr>

<ul>
  <li>参考: <a href="https://ayang.ink/go_%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%A4%E4%B8%AA%E5%8D%8F%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%A5%87%E5%81%B6%E6%95%B0%E5%86%85%E5%90%AB%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/">面试题 - 两个协程交替打印奇偶数（内含三种方法）</a>;<a href="https://juejin.cn/post/7209319092515635261">golang两个协程交替打印</a>;<a href="https://studygolang.com/articles/35057?fr=sidebar">Golang两个协程交替输出</a>
</li>
</ul>

<h3 id="02-什么是协程泄露goroutine-leak">02 什么是协程泄露(Goroutine Leak)？</h3>
<ul>
  <li>定义：协程创建后长时间不释放，并且还在不断的创建新的协程，最终导致内存耗尽，程序崩溃。</li>
  <li>原因：导致协程泄漏的主要场景有以下几种：
    <ul>
      <li>缺少接收器/缺少发送器:，导致对应线程阻塞，无法正常进行退出</li>
      <li>死锁(dead lock):两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出。</li>
      <li>无限循环(infinite loops): 为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏</li>
    </ul>
  </li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 缺少接收器导致死锁</span>
<span class="k">func</span> <span class="n">query</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">0</span> <span class="p">}()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&lt;-</span><span class="n">ch</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">queryTest</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">query</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"goroutines: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">runtime</span><span class="o">.</span><span class="n">NumGoroutine</span><span class="p">())</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c">// goroutines: 1001</span>
<span class="c">// goroutines: 2000</span>
<span class="c">// goroutines: 2999</span>
<span class="c">// goroutines: 3998</span>


<span class="c">// 这里死循环请求</span>
<span class="k">func</span> <span class="n">request</span><span class="p">(</span><span class="n">url</span> <span class="kt">string</span><span class="p">,</span> <span class="n">wg</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">url</span><span class="p">);</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="c">// write to db</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">3</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">waitTest</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="n">request</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"https://127.0.0.1:8080/%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wg</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
<hr>

<ul>
  <li>参考：<a href="https://zhuanlan.zhihu.com/p/383138313">什么是协程泄露(Goroutine Leak)？</a>;<a href="https://blog.csdn.net/qq_37102984/article/details/129326866">Golang http请求忘记调用resp.Body.Close()而导致的协程泄漏问题</a>
</li>
</ul>

<h3 id="03-go-可以限制运行时操作系统线程的数量吗">03 Go 可以限制运行时操作系统线程的数量吗？</h3>

<ul>
  <li>可以；可以使用环境变量 GOMAXPROCS 或 runtime.GOMAXPROCS(num int) 设置，例如：</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="c">// 限制同时执行Go代码的操作系统线程数为 1</span>
</code></pre></div></div>
<p>从官方文档的解释可以看到，GOMAXPROCS 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。GOMAXPROCS 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p>

<hr>

<ul>
  <li>参考：<a href="https://www.zhihu.com/question/584554235/answer/3033310978?utm_id=0">Golang 在 runtime 中的知识点有哪些？</a>;<a href="https://zhuanlan.zhihu.com/p/95056679?from=groupmessage">万字长文深入浅出 Golang Runtime</a>;<a href="https://pkg.go.dev/runtime">go-runtime</a>
</li>
</ul>

<h2 id="代码输出">代码输出</h2>

<h3 id="1-变量与常量">1. 变量与常量</h3>

<ol>
  <li>下面代码的输出是：</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">const</span> <span class="p">(</span>
		<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"golang"</span><span class="p">,</span> <span class="m">100</span>
		<span class="n">d</span><span class="p">,</span> <span class="n">e</span>
		<span class="n">f</span> <span class="kt">bool</span> <span class="o">=</span> <span class="no">true</span>
		<span class="n">g</span>
	<span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// golang 100 true</span>

</code></pre></div></div>
<p>在同一个 const group 中，如果常量定义与前一行的定义一致，则可以省略类型和值。编译时，会按照前一行的定义自动补全。即等价于：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"golang"</span><span class="p">,</span> <span class="m">100</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="s">"golang"</span><span class="p">,</span> <span class="m">100</span>
        <span class="n">f</span> <span class="kt">bool</span> <span class="o">=</span> <span class="no">true</span>
        <span class="n">g</span> <span class="kt">bool</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>下列代码的输出是：</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">N</span> <span class="o">=</span> <span class="m">100</span>
    <span class="k">var</span> <span class="n">x</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">N</span>

    <span class="k">const</span> <span class="n">M</span> <span class="kt">int32</span> <span class="o">=</span> <span class="m">100</span>
    <span class="k">var</span> <span class="n">y</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">M</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 编译失败：cannot use M (type int32) as type int in assignment</span>
</code></pre></div></div>

<p>Go 语言中，常量分为无类型常量和有类型常量两种，const N = 100，属于无类型常量，赋值给其他变量时，如果字面量能够转换为对应类型的变量，则赋值成功，例如，var x int = N。但是对于有类型的常量 const M int32 = 100，赋值给其他变量时，需要类型匹配才能成功，所以显示地类型转换：<code class="language-plaintext highlighter-rouge">var y int = int(M)</code></p>

<ol>
  <li>下列代码的输出是：</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">a</span> <span class="kt">int8</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
    <span class="k">var</span> <span class="n">b</span> <span class="kt">int8</span> <span class="o">=</span> <span class="o">-</span><span class="m">128</span> <span class="o">/</span> <span class="n">a</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// -128</span>
</code></pre></div></div>

<p>int8 能表示的数字的范围是 [-2^7, 2^7-1]，即 [-128, 127]。-128 是无类型常量，转换为 int8，再除以变量 -1，结果为 128，常量除以变量，结果是一个变量。<strong>变量转换时允许溢出</strong>，符号位变为1，转为补码后恰好等于 -128。
对于有符号整型，最高位是是符号位，计算机用补码表示负数。补码 = 原码取反加一。</p>

<pre><code class="language-txt">-1 :  11111111
00000001(原码)    11111110(取反)    11111111(加一)
-128：    
10000000(原码)    01111111(取反)    10000000(加一)

-1 + 1 = 0
11111111 + 00000001 = 00000000(最高位溢出省略)
-128 + 127 = -1
10000000 + 01111111 = 11111111

</code></pre>
<ul>
  <li><strong>正数以原码形式存在，负数以补码形式存在()</strong></li>
  <li><strong>正数最高位为0，负数最高位为1</strong></li>
  <li><strong>最高位为1的需要当作补码转换为负数</strong></li>
</ul>

<ol>
  <li>下列代码的输出是：</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">a</span> <span class="kt">int8</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
    <span class="k">var</span> <span class="n">b</span> <span class="kt">int8</span> <span class="o">=</span> <span class="o">-</span><span class="m">128</span> <span class="o">/</span> <span class="n">a</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译失败：constant 128 overflows int8</p>

<p>-128 和 a 都是常量，在编译时求值，-128 / a = 128，两个常量相除，结果也是一个常量，常量类型转换时不允许溢出，因而编译失败。</p>

<hr>

<ul>
  <li>参考：<a href="https://zhuanlan.zhihu.com/p/129361870">负数在计算机中的储存方式</a>
</li>
</ul>

<h3 id="2-作用域">2. 作用域</h3>

<p>下面的代码输出是</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">err</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"err"</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c">// 1 err</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">:=</code> 表示声明并赋值，<code class="language-plaintext highlighter-rouge">=</code> 表示仅赋值。</p>

<p>变量的作用域是大括号，因此在第一个 <code class="language-plaintext highlighter-rouge">if</code> 语句 <code class="language-plaintext highlighter-rouge">if err == nil</code> 内部重新声明且赋值了与外部变量同名的局部变量 <code class="language-plaintext highlighter-rouge">err</code>。对该局部变量的赋值不会影响到外部的 <code class="language-plaintext highlighter-rouge">err</code>。因此第二个 <code class="language-plaintext highlighter-rouge">if</code> 语句 <code class="language-plaintext highlighter-rouge">if err != nil</code> 不成立。所以只打印了 <code class="language-plaintext highlighter-rouge">1 err</code>。</p>

<h3 id="3-defer延迟调用">3. defer延迟调用</h3>

<ol>
  <li>下面的代码输出是</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">T</span><span class="p">)</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">t</span> <span class="n">T</span>
    <span class="k">defer</span> <span class="n">t</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// 132</span>
</code></pre></div></div>

<p>defer 延迟调用时，需要保存函数指针和参数，因此链式调用的情况下，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 t.f(1) 直接执行，然后执行 fmt.Print(3)，最后函数返回时再执行 .f(2)，因此输出是 132。</p>

<ul>
  <li><strong>语法解析，将defer看作一个函数，函数指针和参数，由最后一个决定</strong></li>
</ul>

<ol>
  <li>下面的代码输出是</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// defer 执行语句与函数，在开始时就确定</span>
    <span class="c">// 这里n进行了值拷贝，输出为1</span>
    <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="m">100</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">f3</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// 这里*n一开始输入就确定了</span>
    <span class="c">// 输出为3</span>
    <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="m">100</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">f2</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// 设置输出为最终的n</span>
    <span class="c">// 因此n输出为102</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">}()</span>
    <span class="c">// 这里直接输出n</span>
    <span class="c">// n 在设置时就确定了，因此为2</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">}(</span><span class="n">n</span><span class="p">)</span>
    <span class="c">// 设置参数为n指针，最终输出为n的引用值</span>
    <span class="c">// 102</span>
    <span class="k">defer</span> <span class="k">func</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
    <span class="p">}(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="m">100</span>

<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="n">f2</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="m">3</span>
    <span class="n">f3</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 1  </span>
<span class="c">// 102</span>
<span class="c">// 2</span>
<span class="c">// 102</span>
<span class="c">// 3</span>
</code></pre></div></div>

<p>defer 语句执行时，会将需要延迟调用的函数和参数保存起来，也就是说，执行到 defer 时，参数 n(此时等于1) 已经被保存了。因此后面对 n 的改动并不会影响延迟函数调用的结果。</p>

<ol>
  <li>下列代码的输出是：</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="m">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="m">100</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// 101</span>
<span class="c">// 1</span>
</code></pre></div></div>
<p>先打印 101，再打印 1。defer 的作用域是函数，而不是代码块，因此 if 语句退出时，defer 不会执行，而是等 101 打印后，整个函数返回时，才会执行。</p>

<h2 id="基础">基础</h2>

<h3 id="1-golang-中-make-和-new-的区别基本必问">1. golang 中 make 和 new 的区别？（基本必问）</h3>

<ol>
  <li>作用不同：
    <ul>
      <li>new: 根据传入的类型分配一片内存空间并返回指向这片内存空间的指针</li>
      <li>make: 初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel，并不负责变量的产生</li>
    </ul>
  </li>
  <li>返回值不同：new 返回的是类型的指针，make返回类型的引用</li>
  <li>使用范围不同：
    <ul>
      <li>new：用于指定类型<code class="language-plaintext highlighter-rouge">T</code> 如<code class="language-plaintext highlighter-rouge">struct</code> 类的初始化</li>
      <li>make: 只能用于 slice，map，channel</li>
    </ul>
  </li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://sanyuesha.com/2017/07/26/go-make-and-new/">Go make 和 new 的区别</a>;<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/">5.5 make 和 new</a>
</li>
</ul>

<h3 id="2-数组和切片的区别-基本必问">2. 数组和切片的区别 （基本必问）</h3>

<p>相同点：</p>
<ul>
  <li>都是顺序存储的数据结构</li>
</ul>

<p>不同点：</p>
<ol>
  <li>长度定义不同：数组是一个长度固定的数据类型，其长度在定义时就已经确定，不能动态改变；切片是一个长度可变的数据类型，其长度在定义时可以为空，也可以指定一个初始长度。</li>
  <li>内存空间分配方式不同：数组的内存空间是在定义时分配的，其大小是固定的；切片的内存空间是在运行时动态分配的，其大小是可变的，在添加时进行<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/#324-%E8%BF%BD%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9">自动扩容</a>
</li>
  <li>操作变更不同：当数组作为函数参数时，函数操作的是数组的一个副本，不会影响原始数组(写时拷贝)；当切片作为函数参数时，函数操作的是切片的引用，会影响原始切片。</li>
  <li>容量不同：切片还有容量的概念，它指的是分配的内存空间。</li>
</ol>

<hr>

<ul>
  <li>参考：<a href="http://www.hangdaowangluo.com/archives/1938">GO中数组与切片的区别</a>;<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/">go数组</a>;<a href="https://www.51cto.com/article/750465.html">Go 语言数组和切片的区别</a>;<a href="https://golang.design/go-questions/slice/vs-array/">数组和切片有什么异同</a>
</li>
</ul>

<h3 id="3-for-range-的时候它的地址会发生变化么">3. for range 的时候它的地址会发生变化么？</h3>

<p>for range 时<strong>地址不会发生变化</strong>，range 会产生一个临时变量，将数组/切片/map 中的值进行拷贝复制，然后进行操作。因此地址不会发生变化，也不应该在range 中对对象进行操作。如果需要修改其值，应当使用指针进行修改，并重新赋值回写。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">girl</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>
	<span class="n">Age</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">gl</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">girl</span><span class="p">)</span>
	<span class="n">studs</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">girl</span><span class="p">{</span>
		<span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Lili"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">23</span><span class="p">},</span>
		<span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Lucy"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">24</span><span class="p">},</span>
		<span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"Han Mei"</span><span class="p">,</span> <span class="n">Age</span><span class="o">:</span> <span class="m">21</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">studs</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s addr: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="o">.</span><span class="n">Age</span><span class="p">)</span>
		<span class="n">gl</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">Name</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">mk</span><span class="p">,</span> <span class="n">mv</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">gl</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">mk</span><span class="p">,</span> <span class="s">"=&gt;"</span><span class="p">,</span> <span class="n">mv</span><span class="o">.</span><span class="n">Age</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c">// main.go</span>
<span class="c">// Lili addr: 0xc0000a4028</span>
<span class="c">// Lili =&gt; 21</span>
<span class="c">// Lucy addr: 0xc0000a4028</span>
<span class="c">// Lucy =&gt; 21</span>
<span class="c">// Han Mei addr: 0xc0000a4028</span>
<span class="c">// Han Mei =&gt; 21</span>

</code></pre></div></div>

<h3 id="4-go-defer多个-defer-的顺序defer-在什么时机会修改返回值">4. go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</h3>

<p>defer 按照栈的顺序，先入后出。按照定义顺序逆序执行。defer 在返回值定义后，最终return 之前修改返回值</p>

<h3 id="5-uint-类型溢出">5. uint 类型溢出</h3>

<p>uint 最大值为 2^31-1 当期超过最大值时，会从最小值开始循环。为了防止溢出可以采用以下方案：</p>
<ol>
  <li>使用更大的数据类型：例如，如果你正在使用uint32，你可以尝试升级到uint64。这将提供更大的值范围，从而减少溢出的可能性。</li>
  <li>添加溢出检查：在每次运算之后，你可以检查结果是否小于任一操作数（假设我们只在正数上进行操作）。如果是这样，那么就发生了溢出。</li>
  <li>使用 math/big 包：对于非常大的数值，你也可以考虑使用 math/big 包中的 Int 类型。这个类型可以处理任意大小的数值，但是运算速度会慢一些。</li>
</ol>

<h3 id="6-介绍-rune-类型">6. 介绍 rune 类型</h3>

<p>rune 类型是go 针对字符集产生的特殊类型，基本定义为int32 别名，长度为4个字节，可以任意字符值。用于解决多字符集编码问题(utf-8)</p>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/rJDC5vuwJCNoUJI5HH4uiaAYjK4vIgnu7W7h9Y0LezHISIzDTxDCE6FVVxzUb6gefUYo2X5mraBO4p9uiaK0QRuA/640?wx_fmt=png" alt="字符编码"></p>

<p>rune 类型只是一种名称叫法，表示用来处理长度大于 1 字节（ 8 位）、不超过 4 字节（ 32 位）的字符类型。但万变不离其宗，我们使用函数时，无论传入参数的是原始字符串还是 rune，最终都是对字节进行处理。</p>

<hr>

<ul>
  <li>参考：<a href="https://zhuanlan.zhihu.com/p/137339284">理解go中rune数据类型</a>;<a href="https://www.cnblogs.com/cheyunhua/p/16007219.html">详解 Go 中的 rune 类型</a>
</li>
</ul>

<h3 id="7-golang-中解析-tag-是怎么实现的反射原理是什么">7. golang 中解析 tag 是怎么实现的？反射原理是什么？</h3>

<ul>
  <li>tag实现： golang 中的tag 是通过反射进行解析实现的，tag解析方法如下：</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">User</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Name</span> <span class="kt">string</span> <span class="s">`testTag:"name"`</span>
        <span class="n">Age</span> <span class="kt">int</span> <span class="s">`testTag:"age"`</span>
    <span class="p">}</span>
    <span class="n">v</span> <span class="o">:=</span> <span class="n">refect</span><span class="o">.</span><span class="n">Valueof</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">Type</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="n">NumField</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">field</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">Fieid</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">tagName</span> <span class="o">:=</span>  <span class="n">field</span><span class="o">.</span><span class="n">Tag</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"testTag"</span><span class="p">)</span>
        <span class="n">fieldVal</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">FieldByName</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"tagName %v val %v"</span><span class="p">,</span> <span class="n">tagName</span><span class="p">,</span> <span class="n">fieldVal</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>反射原理：通过接口的隐式转换将普通类型转换为interface{}，在将interface{}转换为反射类型来实现，通过反射基础类型操作，实现各种复杂操作。</li>
</ul>

<p><img src="https://pic3.zhimg.com/v2-e0bb3510209442e76b2a244cec85b3fa_r.jpg" alt="反射流程"></p>

<ul>
  <li>反射三定律：
    <ul>
      <li>Golang对象可以转换成反射对象</li>
      <li>反射对象可以转换成Golang对象</li>
      <li>可寻址的reflect对象可以更新值</li>
    </ul>
  </li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/">go反射原理</a>;<a href="https://zhuanlan.zhihu.com/p/382424874">Golang反射原理详解</a>;<a href="https://golang.design/go-questions/stdlib/reflect/how/">go语言如何实现发射</a>
</li>
</ul>

<h3 id="8-调用函数传入结构体时应该传值还是指针-golang-都是传值">8. 调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）</h3>

<p>传入的是值，golang都是值传递，即便是指针，也进行了一次值拷贝</p>

<h3 id="9-go-空结构体为啥内存为0">9. go 空结构体为啥内存为0</h3>

<p>这个是go的编译时优化，因为空结构不包含任何字段，因此不能容纳任何数据。如果空结构不包含任何数据，则无法确定两个结构{} 值是否不同。它们实际上是可替代的</p>

<p>空结构体主要有以下几个特点：</p>
<ul>
  <li>零内存占用</li>
  <li>地址相同</li>
  <li>无状态</li>
</ul>

<p>使用场景：</p>
<ul>
  <li>实现 Set 集合类型</li>
  <li>用于通道信号</li>
  <li>作为方法接收器</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// /go/src/runtime/malloc.go</span>
<span class="c">// base address for all 0-byte allocations</span>
<span class="k">var</span> <span class="n">zerobase</span> <span class="kt">uintptr</span>

<span class="k">func</span> <span class="n">mallocgc</span><span class="p">(</span><span class="n">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="n">typ</span> <span class="o">*</span><span class="n">_type</span><span class="p">,</span> <span class="n">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
   
    <span class="err">······</span>

    <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
   
       <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zerobase</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="err">······</span>
</code></pre></div></div>

<p>根据 malloc.go 源码的部分内容，当要分配的对象大小 size 为 0 时，会返回指向 zerobase 的指针。zerobase 是一个用于分配零字节对象的基准地址，它不占用任何实际的内存空间。</p>

<hr>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td colspan="2">参考：<a href="https://developer.aliyun.com/article/1230762">Go空结构体:零内存的魔力</a>;[翻译</td>
          
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="10-能说说uintptr和unsafepointer的区别吗">10 能说说uintptr和unsafe.Pointer的区别吗？</h3>

<ul>
  <li>unsafe.Pointer还会被gc追踪而uintptr不会；</li>
  <li>uintptr是整形而unsafe.Pointer是指针类型，uintptr可以和任何类型的整形互转，unsafe.Pointer可以和任何类型的指针互转，然后它们俩之间可以互转。</li>
</ul>

<hr>

<p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzkzODY1MDQyMA==&mid=2247483656&idx=1&sn=1cc955dbf2b2a25fe93d55b6a14406db&chksm=c2fdbf53f58a36450086724482507d0f7bcf6cc204fb95b98e8a6ce5aed6c2b88b649073728b&token=1922909448&lang=zh_CN#rd">GO 普通指针&amp;unsafe.Pointer&amp;uintptr</a>;<a href="https://www.zhihu.com/question/584325156">知乎-uintptr和unsafe.Pointer区别</a></p>

<h2 id="context相关">context相关</h2>

<h3 id="1-context-结构是什么样的">1. context 结构是什么样的？</h3>
<p>context 是go 定义的官方上下文接口，其本质是一个标准接口定义如下</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// context/context.go</span>
<span class="k">type</span> <span class="n">Context</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="c">// Deadline returns the time when work done on behalf of this context</span>
	<span class="c">// should be canceled. Deadline returns ok==false when no deadline is</span>
	<span class="c">// set. Successive calls to Deadline return the same results.</span>
	<span class="n">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="n">deadline</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">,</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">)</span>

	<span class="c">// Done returns a channel that's closed when work done on behalf of this</span>
	<span class="c">// context should be canceled. Done may return nil if this context can</span>
	<span class="c">// never be canceled. Successive calls to Done return the same value.</span>
	<span class="c">// The close of the Done channel may happen asynchronously,</span>
	<span class="c">// after the cancel function returns.</span>
	<span class="c">//</span>
	<span class="c">// WithCancel arranges for Done to be closed when cancel is called;</span>
	<span class="c">// WithDeadline arranges for Done to be closed when the deadline</span>
	<span class="c">// expires; WithTimeout arranges for Done to be closed when the timeout</span>
	<span class="c">// elapses.</span>
	<span class="c">//</span>
	<span class="c">// Done is provided for use in select statements:</span>
	<span class="c">//</span>
	<span class="c">//  // Stream generates values with DoSomething and sends them to out</span>
	<span class="c">//  // until DoSomething returns an error or ctx.Done is closed.</span>
	<span class="c">//  func Stream(ctx context.Context, out chan&lt;- Value) error {</span>
	<span class="c">//  	for {</span>
	<span class="c">//  		v, err := DoSomething(ctx)</span>
	<span class="c">//  		if err != nil {</span>
	<span class="c">//  			return err</span>
	<span class="c">//  		}</span>
	<span class="c">//  		select {</span>
	<span class="c">//  		case &lt;-ctx.Done():</span>
	<span class="c">//  			return ctx.Err()</span>
	<span class="c">//  		case out &lt;- v:</span>
	<span class="c">//  		}</span>
	<span class="c">//  	}</span>
	<span class="c">//  }</span>
	<span class="c">//</span>
	<span class="c">// See https://blog.golang.org/pipelines for more examples of how to use</span>
	<span class="c">// a Done channel for cancellation.</span>
	<span class="n">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{}</span>

	<span class="c">// If Done is not yet closed, Err returns nil.</span>
	<span class="c">// If Done is closed, Err returns a non-nil error explaining why:</span>
	<span class="c">// Canceled if the context was canceled</span>
	<span class="c">// or DeadlineExceeded if the context's deadline passed.</span>
	<span class="c">// After Err returns a non-nil error, successive calls to Err return the same error.</span>
	<span class="n">Err</span><span class="p">()</span> <span class="kt">error</span>

	<span class="c">// Value returns the value associated with this context for key, or nil</span>
	<span class="c">// if no value is associated with key. Successive calls to Value with</span>
	<span class="c">// the same key returns the same result.</span>
	<span class="c">//</span>
	<span class="c">// Use context values only for request-scoped data that transits</span>
	<span class="c">// processes and API boundaries, not for passing optional parameters to</span>
	<span class="c">// functions.</span>
	<span class="c">//</span>
	<span class="c">// A key identifies a specific value in a Context. Functions that wish</span>
	<span class="c">// to store values in Context typically allocate a key in a global</span>
	<span class="c">// variable then use that key as the argument to context.WithValue and</span>
	<span class="c">// Context.Value. A key can be any type that supports equality;</span>
	<span class="c">// packages should define keys as an unexported type to avoid</span>
	<span class="c">// collisions.</span>
	<span class="c">//</span>
	<span class="c">// Packages that define a Context key should provide type-safe accessors</span>
	<span class="c">// for the values stored using that key:</span>
	<span class="c">//</span>
	<span class="c">// 	// Package user defines a User type that's stored in Contexts.</span>
	<span class="c">// 	package user</span>
	<span class="c">//</span>
	<span class="c">// 	import "context"</span>
	<span class="c">//</span>
	<span class="c">// 	// User is the type of value stored in the Contexts.</span>
	<span class="c">// 	type User struct {...}</span>
	<span class="c">//</span>
	<span class="c">// 	// key is an unexported type for keys defined in this package.</span>
	<span class="c">// 	// This prevents collisions with keys defined in other packages.</span>
	<span class="c">// 	type key int</span>
	<span class="c">//</span>
	<span class="c">// 	// userKey is the key for user.User values in Contexts. It is</span>
	<span class="c">// 	// unexported; clients use user.NewContext and user.FromContext</span>
	<span class="c">// 	// instead of using this key directly.</span>
	<span class="c">// 	var userKey key</span>
	<span class="c">//</span>
	<span class="c">// 	// NewContext returns a new Context that carries value u.</span>
	<span class="c">// 	func NewContext(ctx context.Context, u *User) context.Context {</span>
	<span class="c">// 		return context.WithValue(ctx, userKey, u)</span>
	<span class="c">// 	}</span>
	<span class="c">//</span>
	<span class="c">// 	// FromContext returns the User value stored in ctx, if any.</span>
	<span class="c">// 	func FromContext(ctx context.Context) (*User, bool) {</span>
	<span class="c">// 		u, ok := ctx.Value(userKey).(*User)</span>
	<span class="c">// 		return u, ok</span>
	<span class="c">// 	}</span>
	<span class="n">Value</span><span class="p">(</span><span class="n">key</span> <span class="n">any</span><span class="p">)</span> <span class="n">any</span>
<span class="p">}</span>

</code></pre></div></div>

<p>go 官方包中提供了默认的emptyCtx 进行常规使用</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">emptyCtx</span> <span class="kt">int</span>
<span class="c">// 执行deadline</span>
<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">emptyCtx</span><span class="p">)</span> <span class="n">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="n">deadline</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">,</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c">// 执行相关操作</span>
<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">emptyCtx</span><span class="p">)</span> <span class="n">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// 对应错误信息</span>
<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">emptyCtx</span><span class="p">)</span> <span class="n">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// 查询对应值</span>
<span class="k">func</span> <span class="p">(</span><span class="o">*</span><span class="n">emptyCtx</span><span class="p">)</span> <span class="n">Value</span><span class="p">(</span><span class="n">key</span> <span class="n">any</span><span class="p">)</span> <span class="n">any</span> <span class="p">{</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// 字符串</span>
<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span><span class="n">emptyCtx</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">e</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">background</span><span class="o">:</span>
		<span class="k">return</span> <span class="s">"context.Background"</span>
	<span class="k">case</span> <span class="n">todo</span><span class="o">:</span>
		<span class="k">return</span> <span class="s">"context.TODO"</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">"unknown empty Context"</span>
<span class="p">}</span>

<span class="k">var</span> <span class="p">(</span>
	<span class="n">background</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">emptyCtx</span><span class="p">)</span>
	<span class="n">todo</span>       <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">emptyCtx</span><span class="p">)</span>
<span class="p">)</span>

<span class="c">// Background returns a non-nil, empty Context. It is never canceled, has no</span>
<span class="c">// values, and has no deadline. It is typically used by the main function,</span>
<span class="c">// initialization, and tests, and as the top-level Context for incoming</span>
<span class="c">// requests.</span>
<span class="k">func</span> <span class="n">Background</span><span class="p">()</span> <span class="n">Context</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">background</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="2-context-使用场景和用途">2. context 使用场景和用途</h3>

<p>context 主要用于协程之间进行数据传递和信号发送，基于此的主要使用场景和用途如下：</p>

<ol>
  <li>上下文传递数据：函数之间的值传递</li>
  <li>超时控制：http 定时器等超时控制、IO 耗时操作控制超时</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">httpRequest</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c">// 处理http请求</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Request timed out"</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Loading..."</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"start TestTimeoutContext"</span><span class="p">)</span>
	<span class="n">ctx</span><span class="p">,</span> <span class="n">cancel</span> <span class="o">:=</span> <span class="n">context</span><span class="o">.</span><span class="n">WithTimeout</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">(),</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="m">3</span><span class="p">)</span>
	<span class="k">defer</span> <span class="n">cancel</span><span class="p">()</span>
	<span class="n">httpRequest</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="m">5</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">//start TestTimeoutContext</span>
<span class="c">//Loading...</span>
<span class="c">//Loading...</span>
<span class="c">//Request timed out</span>
</code></pre></div></div>

<ol>
  <li>信号发送(取消控制)
    <ul>
      <li>控制子协程退出：goroutine发送取消信号，保证自己这个逻辑中发散出去的goroutine全部成功取消</li>
    </ul>
  </li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">gen</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">n</span> <span class="kt">int</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">n</span><span class="o">:</span>
				<span class="n">n</span><span class="o">++</span>
				<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">ctx</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="o">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="n">ch</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// 创建一个Cancel context</span>
	<span class="n">ctx</span><span class="p">,</span> <span class="n">cancel</span> <span class="o">:=</span> <span class="n">context</span><span class="o">.</span><span class="n">WithCancel</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">())</span>
	<span class="k">defer</span> <span class="n">cancel</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">gen</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="m">5</span> <span class="p">{</span>
			<span class="c">// 达到要求之后触发cancel</span>
			<span class="n">cancel</span><span class="p">()</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c">//0</span>
<span class="c">//1</span>
<span class="c">//2</span>
<span class="c">//3</span>
<span class="c">//4</span>
<span class="c">//5</span>
</code></pre></div></div>

<hr>

<ul>
  <li>参考：<a href="https://juejin.cn/post/7140872374534012964">Golang Context的使用场景</a>
</li>
</ul>

<h2 id="channel相关">channel相关</h2>

<h3 id="1-channel-是否线程安全锁用在什么地方">1. channel 是否线程安全？锁用在什么地方？</h3>

<ul>
  <li>channel 是线程安全的：
    <ul>
      <li>设计需要：channel 本身设定为golang 中多协程通信语法糖，使用场景就是多线程，为了保证数据的一致性，必须实现线程安全。</li>
      <li>设计实现：底层实现中<code class="language-plaintext highlighter-rouge">hchan</code> 使用<code class="language-plaintext highlighter-rouge">mutex</code>互斥锁保证数据读写安全， 在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据。同时使用堆上内存共享，保证通信高效性</li>
    </ul>
  </li>
  <li>go 中的锁分为：
    <ul>
      <li>sync.Mutex (互斥锁)：只包含<code class="language-plaintext highlighter-rouge">lock()</code>与<code class="language-plaintext highlighter-rouge">unlock</code>的基础互斥锁</li>
      <li>sync.RWMutex (读写锁):针对读多写少的环境进行。包含<code class="language-plaintext highlighter-rouge">RLock()/RUnlock()</code>(读锁)、<code class="language-plaintext highlighter-rouge">Lock()/Unlock()</code>(写锁方法)</li>
      <li>sync.Map(安全锁)：并发map安全锁</li>
      <li>sync.WaitGroup(删栏)：用<code class="language-plaintext highlighter-rouge">Add(int)/Done()</code> 用于增加持有次数。<code class="language-plaintext highlighter-rouge">Wait()</code> 进行持有等待</li>
    </ul>
  </li>
</ul>

<hr>

<p>参考：<a href="https://blog.csdn.net/qq_52563729/article/details/126093532">go笔记记录——channel</a>;<a href="https://www.kancloud.cn/yuankejishu/golang/2785000">Go中的三种锁包括:互斥锁,读写锁,sync.Map的安全的锁.</a></p>

<h3 id="2-go-channel-的底层实现原理-数据结构">2. go channel 的底层实现原理 （数据结构）</h3>

<p>Go中的channel是一个队列，遵循先进先出的原则，负责协程之间的通信(Go语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP(CommunicatingSequentiall Process)并发模型，就是通过goroutine和channel来实现的)</p>

<p>通过var声明或者make函数创建的channel变量是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体</p>

<p><img src="https://img-blog.csdnimg.cn/4c5a4b62c9dd4522abeae054e11456f1.png" alt=""></p>

<p>底层数据结构如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">hchan</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">qcount</span>   <span class="kt">uint</span>           <span class="c">// 队列中的总元素个数</span>
	<span class="n">dataqsiz</span> <span class="kt">uint</span>           <span class="c">// 环形队列大小，即可存放元素的个数</span>
	<span class="n">buf</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// 环形队列指针</span>
	<span class="n">elemsize</span> <span class="kt">uint16</span> <span class="c">//每个元素的大小</span>
	<span class="n">closed</span>   <span class="kt">uint32</span> <span class="c">//标识关闭状态</span>
	<span class="n">elemtype</span> <span class="o">*</span><span class="n">_type</span> <span class="c">// 元素类型</span>
	<span class="n">sendx</span>    <span class="kt">uint</span>   <span class="c">// 发送索引，元素写入时存放到队列中的位置</span>
	<span class="n">recvx</span>    <span class="kt">uint</span>   <span class="c">// 接收索引，元素从队列的该位置读出</span>
	<span class="n">recvq</span>    <span class="n">waitq</span>  <span class="c">// 等待读消息的goroutine队列</span>
	<span class="n">sendq</span>    <span class="n">waitq</span>  <span class="c">// 等待写消息的goroutine队列</span>

	<span class="c">// lock protects all fields in hchan, as well as several</span>
	<span class="c">// fields in sudogs blocked on this channel.</span>
	<span class="c">//</span>
	<span class="c">// Do not change another G's status while holding this lock</span>
	<span class="c">// (in particular, do not ready a G), as this can deadlock</span>
	<span class="c">// with stack shrinking.</span>
	<span class="n">lock</span> <span class="n">mutex</span> <span class="c">//互斥锁，chan不允许并发读写</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">waitq</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">first</span> <span class="o">*</span><span class="n">sudog</span>
	<span class="n">last</span>  <span class="o">*</span><span class="n">sudog</span>
<span class="p">}</span>

<span class="c">// sudog represents a g in a wait list, such as for sending/receiving</span>
<span class="c">// on a channel.</span>
<span class="c">//</span>
<span class="c">// sudog is necessary because the g ↔ synchronization object relation</span>
<span class="c">// is many-to-many. A g can be on many wait lists, so there may be</span>
<span class="c">// many sudogs for one g; and many gs may be waiting on the same</span>
<span class="c">// synchronization object, so there may be many sudogs for one object.</span>
<span class="c">//</span>
<span class="c">// sudogs are allocated from a special pool. Use acquireSudog and</span>
<span class="c">// releaseSudog to allocate and free them.</span>
<span class="k">type</span> <span class="n">sudog</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// The following fields are protected by the hchan.lock of the</span>
	<span class="c">// channel this sudog is blocking on. shrinkstack depends on</span>
	<span class="c">// this for sudogs involved in channel ops.</span>

	<span class="n">g</span> <span class="o">*</span><span class="n">g</span>

	<span class="n">next</span> <span class="o">*</span><span class="n">sudog</span>
	<span class="n">prev</span> <span class="o">*</span><span class="n">sudog</span>
	<span class="n">elem</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// data element (may point to stack)</span>

	<span class="c">// The following fields are never accessed concurrently.</span>
	<span class="c">// For channels, waitlink is only accessed by g.</span>
	<span class="c">// For semaphores, all fields (including the ones above)</span>
	<span class="c">// are only accessed when holding a semaRoot lock.</span>

	<span class="n">acquiretime</span> <span class="kt">int64</span>
	<span class="n">releasetime</span> <span class="kt">int64</span>
	<span class="n">ticket</span>      <span class="kt">uint32</span>

	<span class="c">// isSelect indicates g is participating in a select, so</span>
	<span class="c">// g.selectDone must be CAS'd to win the wake-up race.</span>
	<span class="n">isSelect</span> <span class="kt">bool</span>

	<span class="c">// success indicates whether communication over channel c</span>
	<span class="c">// succeeded. It is true if the goroutine was awoken because a</span>
	<span class="c">// value was delivered over channel c, and false if awoken</span>
	<span class="c">// because c was closed.</span>
	<span class="n">success</span> <span class="kt">bool</span>

	<span class="n">parent</span>   <span class="o">*</span><span class="n">sudog</span> <span class="c">// semaRoot binary tree</span>
	<span class="n">waitlink</span> <span class="o">*</span><span class="n">sudog</span> <span class="c">// g.waiting list or semaRoot</span>
	<span class="n">waittail</span> <span class="o">*</span><span class="n">sudog</span> <span class="c">// semaRoot</span>
	<span class="n">c</span>        <span class="o">*</span><span class="n">hchan</span> <span class="c">// channel</span>
<span class="p">}</span>
</code></pre></div></div>

<hr>

<ul>
  <li>参考：<a href="https://golang.design/go-questions/channel/struct/">channel 底层的数据结构是什么</a>
</li>
</ul>

<h3 id="3-关闭的-channel-有数据的-channel再进行读-写-关闭会怎么样各类变种题型">3. 关闭的 channel. 有数据的 channel，再进行读. 写. 关闭会怎么样？（各类变种题型）</h3>

<p>在Go的并发模型中，关闭channel是为了告诉接收者，发送者没有更多的数据要发送了。因此，一旦channel被关闭，就意味着不能再向其发送新的数据。这种约定帮助程序员在处理并发逻辑时，能够更好地理解数据流的生命周期。</p>

<ul>
  <li>关闭的channel：
    <ul>
      <li>读：无异常，如果在关闭前，通道内部有元素，会正确读到元素的值；如果关闭前通道无元素，则会读取到通道内元素类型对应的零值。range 操作可能会导致死锁错误</li>
      <li>写/关闭：panic</li>
    </ul>
  </li>
  <li>有数据channel:
    <ul>
      <li>读：正常读取到数据</li>
      <li>写/关闭：panic</li>
    </ul>
  </li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://studygolang.com/topics/15595">《Go题库·2》对已经关闭的channel进行读写操作会发生什么?</a>;<a href="https://www.iamshuaidi.com/23380.html">对已经关闭的的chan进行读写，会怎么样？为什么？</a>
</li>
</ul>

<h3 id="4-向-channel-发送数据和从-channel-读数据的流程是什么样的">4. 向 channel 发送数据和从 channel 读数据的流程是什么样的？</h3>

<ul>
  <li>发送数据：
    <ol>
      <li>若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。</li>
      <li>若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。</li>
      <li>若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。</li>
    </ol>
  </li>
</ul>

<p><img src="https://golang.design/go-questions/channel/assets/2.png" alt="进行数据写入"></p>

<ul>
  <li>读取数据：
    <ol>
      <li>若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程；</li>
      <li>如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程；</li>
      <li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；</li>
      <li>将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒；</li>
    </ol>
  </li>
  <li>关闭 channel
关闭 channel 时会将 recvq 中的 G 全部唤醒，，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。</li>
</ul>

<p>panic 出现的场景还有：</p>
<ul>
  <li>关闭值为 nil 的 channel</li>
  <li>关闭已经关闭的 channel</li>
  <li>向已经关闭的 channel 中写数据</li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://golang.design/go-questions/channel/recv/">从 channel 接收数据的过程是怎样的</a>;<a href="https://golang.design/go-questions/channel/send/">向 channel 发送数据的过程是怎样的</a>;<a href="https://xie.infoq.cn/article/49526fb0dde758d663dfe0cd0">Go 语言 chan 实现原理，彻底搞懂 chan 读写机制</a>
</li>
</ul>

<h2 id="map相关">map相关</h2>

<h3 id="1-map-使用注意的点并发安全">1. map 使用注意的点，并发安全？</h3>

<ol>
  <li>map为引用类型，需要注意底层数据变换：如果两个map同时指向一个底层，那么一个map的变动会影响到另一个map</li>
  <li>初始化：map 默认为nil,需要使用make进行初始化，对nil map进行任何添加元素的操作都会触发运行时错误（panic）。因此，使用前必须先创建map，使用make函数，例如：m := make(map[string]int)。</li>
  <li>map的键必须可比较： map的键可以是任何可以用==或!=操作符比较的类型：如字符串，整数，浮点数，复数，布尔等。但是slice，map，和function类型不可以作为map的键，因为这些类型不能使用==或!=操作符进行比较。</li>
  <li>map在使用过程中不保证遍历顺序：map的遍历结果顺序可能会不一样，所以在需要顺序的场合，要自行处理数据并排序。map底层使用hash桶进行数据存储，扩容过程中不保证数据有效性。不能边遍历，边修改key</li>
  <li>非线程安全：map进行的所有操作，包括读取，写入，删除，都是不安全的，也就是说，如果你在一个goroutine中修改map，同时在另一个goroutine中读取map，可能会触发“concurrent map read and map write”的错误。需要使用锁或者sync.Map 进行数据操作</li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://www.iamshuaidi.com/23354.html">请说一下Golang map 使用注意的点，以及是否并发安全？</a>
</li>
</ul>

<h3 id="2-map-循环是有序的还是无序的">2. map 循环是有序的还是无序的？</h3>

<ul>
  <li>无序的：无序有两个关键点：
    <ol>
      <li>map扩容无序性：map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</li>
      <li>map 遍历随机性：遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了</li>
    </ol>
  </li>
</ul>

<h3 id="3-map-中删除一个-key它的内存会释放么">3. map 中删除一个 key，它的内存会释放么？</h3>

<ul>
  <li>不会：仅仅修改可用标记，不会真正释放内存。只有真正进行删除后，才会进行内存的释放</li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://qcrao91.gitbook.io/go/map/map-de-shan-chu-guo-cheng-shi-zen-yang-de">map 的删除过程是怎样的</a>;<a href="https://juejin.cn/post/7195528153905184829">面试官：map删除元素会释放内存吗</a>;<a href="https://www.mofan.life/2022/11/14/Go/Go%E5%88%A0%E9%99%A4Map%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D/">Go删除Map对内存的影响</a>
</li>
</ul>

<h3 id="4-怎么处理对-map-进行并发访问有没有其他方案-区别是什么">4. 怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？</h3>

<ol>
  <li>使用锁：使用RWLock 或者Mutex锁进行读写访问控制</li>
  <li>使用sync.Map线程安全锁:</li>
  <li>分片加锁：将这个 map 分成 n 块，每个块之间的读写操作都互不干扰，从而降低冲突的可能性。</li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://blog.csdn.net/weixin_43973689/article/details/127986224">实现map并发安全的三种方式</a>;<a href="https://www.cnblogs.com/chenpingzhao/p/16322422.html">【Golang】 关于Go 并发之三种线程安全的 map</a>
</li>
</ul>

<h3 id="5-nil-map-和空-map-有何不同">5. nil map 和空 map 有何不同？</h3>

<ul>
  <li>nil map: 未初始化的map,不能进行读写操作</li>
  <li>空map：已经初始化的map。只是没有数据，可以正常读写。</li>
  <li>map初始化注意点：
    <ul>
      <li>希表中的元素数量少于或者等于 25 个时，编译器会将字面量初始化的结构体转换成对应代码，直接一次加入到hash表中</li>
      <li>超过25个：创建两个数组存储键和值，通过循环进行加入</li>
    </ul>
  </li>
</ul>

<h3 id="6-map-的数据结构是什么是怎么实现扩容">6. map 的数据结构是什么？是怎么实现扩容？</h3>

<h4 id="map数据结构hmap">map数据结构–hmap</h4>
<p>Golang的map就是使用哈希表作为底层实现，map 实际上就是一个指针，指向hmap结构体。其主要数据结构如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">hmap</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">count</span>     <span class="kt">int</span>              <span class="c">// 存储的键值对数目,调用len时直接返回此值</span>
  <span class="n">flags</span>     <span class="kt">uint8</span>            <span class="c">// 状态标志（是否处于正在写入的状态等）</span>
  <span class="n">B</span>         <span class="kt">uint8</span>            <span class="c">// 桶的数目为 2^B</span>
  <span class="n">noverflow</span> <span class="kt">uint16</span>           <span class="c">// 使用的溢出桶的数量</span>
  <span class="n">hash0</span>     <span class="kt">uint32</span>           <span class="c">// 生成hash的随机数种子</span>

  <span class="n">buckets</span>    <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>  <span class="c">// bucket数组指针，数组的大小为2^B（桶）</span>
  <span class="n">oldbuckets</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>  <span class="c">// 扩容阶段用于记录旧桶用到的那些溢出桶的地址</span>
  <span class="n">nevacuate</span>  <span class="kt">uintptr</span>         <span class="c">// 记录渐进式扩容阶段下一个要迁移的旧桶编号</span>
  <span class="n">extra</span> <span class="o">*</span><span class="n">mapextra</span>            <span class="c">// 指向mapextra结构体里边记录的都是溢出桶相关的信息</span>
<span class="p">}</span>


<span class="c">//  buckets 指向的真实指针地址</span>
<span class="k">type</span> <span class="n">bmap</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">topbits</span>  <span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="kt">uint8</span>   <span class="c">// 高位字段，用于进行快速的hash查找</span>
    <span class="n">keys</span>     <span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="n">keytype</span>  <span class="c">// key数组</span>
    <span class="n">values</span>   <span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="n">valuetype</span> <span class="c">// val数组</span>
    <span class="n">pad</span>      <span class="kt">uintptr</span> <span class="c">// 字节对齐扩充字段</span>
    <span class="n">overflow</span> <span class="kt">uintptr</span> <span class="c">// 溢出桶指针地址</span>
<span class="p">}</span>

</code></pre></div></div>

<p><img src="https://golang.design/go-questions/map/assets/0.png" alt="hash map"></p>

<h4 id="扩容实现">扩容实现</h4>

<p><strong>扩容条件</strong>
在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p>
<ul>
  <li>装载因子超过阈值，源码里定义的阈值是 6.5。</li>
  <li>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。</li>
</ul>

<p>由此引发出两种扩容方式：</p>
<ul>
  <li>翻倍扩容：直接进行翻倍扩容</li>
  <li>等量扩容：创建新桶保存数据，清理溢出桶</li>
</ul>

<p>扩容过程的关键代码如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">// map扩容</span>
<span class="k">func</span> <span class="n">mapassign</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">maptype</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span><span class="n">hmap</span><span class="p">,</span> <span class="n">key</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="p">{</span>
	<span class="o">...</span>
<span class="n">again</span><span class="o">:</span>
	<span class="n">bucket</span> <span class="o">:=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="n">bucketMask</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
    <span class="c">// 已经处于扩容</span>
	<span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">growing</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// 执行真正的扩容函数</span>
		<span class="n">growWork</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">bucket</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">bmap</span><span class="p">)(</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">buckets</span><span class="p">,</span> <span class="n">bucket</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">bucketsize</span><span class="p">)))</span>
	<span class="n">top</span> <span class="o">:=</span> <span class="n">tophash</span><span class="p">(</span><span class="n">hash</span><span class="p">)</span>

    
    <span class="o">...</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="n">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">overLoadFactor</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">count</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="o">||</span> <span class="n">tooManyOverflowBuckets</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">noverflow</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">B</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hashGrow</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">growWork</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">maptype</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span><span class="n">hmap</span><span class="p">,</span> <span class="n">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// make sure we evacuate the oldbucket corresponding</span>
	<span class="c">// to the bucket we're about to use</span>
	<span class="n">evacuate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">bucket</span><span class="o">&amp;</span><span class="n">h</span><span class="o">.</span><span class="n">oldbucketmask</span><span class="p">())</span>

	<span class="c">// evacuate one more oldbucket to make progress on growing</span>
	<span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">evacuate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// overflow buckets 太多</span>
<span class="k">func</span> <span class="n">tooManyOverflowBuckets</span><span class="p">(</span><span class="n">noverflow</span> <span class="kt">uint16</span><span class="p">,</span> <span class="n">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">B</span> <span class="o">&lt;</span> <span class="m">16</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">noverflow</span> <span class="o">&gt;=</span> <span class="kt">uint16</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">B</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">noverflow</span> <span class="o">&gt;=</span> <span class="m">1</span><span class="o">&lt;&lt;</span><span class="m">15</span>
<span class="p">}</span>

<span class="c">// 创建新桶内存空间</span>
<span class="k">func</span> <span class="n">hashGrow</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">maptype</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span><span class="n">hmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">bigger</span> <span class="o">:=</span> <span class="kt">uint8</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="c">// 检查是否为装载因子过高</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">overLoadFactor</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">count</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bigger</span> <span class="o">=</span> <span class="m">0</span>
		<span class="n">h</span><span class="o">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">sameSizeGrow</span>
	<span class="p">}</span>
	<span class="n">oldbuckets</span> <span class="o">:=</span> <span class="n">h</span><span class="o">.</span><span class="n">buckets</span>
    <span class="c">// 进行数据扩容</span>
    <span class="c">// 1. 创建新桶和溢出桶</span>
    <span class="c">// 2. 设置oldbuckets和buckets 值</span>
	<span class="c">// 为新桶分配内存</span>
    <span class="n">newbuckets</span><span class="p">,</span> <span class="n">nextOverflow</span> <span class="o">:=</span> <span class="n">makeBucketArray</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">B</span><span class="o">+</span><span class="n">bigger</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
    <span class="c">// 扩容倍数</span>
	<span class="n">h</span><span class="o">.</span><span class="n">B</span> <span class="o">+=</span> <span class="n">bigger</span>
	<span class="n">h</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>
    <span class="c">// 设置新旧桶</span>
	<span class="n">h</span><span class="o">.</span><span class="n">oldbuckets</span> <span class="o">=</span> <span class="n">oldbuckets</span>
	<span class="n">h</span><span class="o">.</span><span class="n">buckets</span> <span class="o">=</span> <span class="n">newbuckets</span>
	<span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span> <span class="o">=</span> <span class="m">0</span>
	<span class="n">h</span><span class="o">.</span><span class="n">noverflow</span> <span class="o">=</span> <span class="m">0</span>

	<span class="n">h</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">oldoverflow</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">overflow</span>
	<span class="n">h</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">overflow</span> <span class="o">=</span> <span class="no">nil</span>
	<span class="n">h</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">nextOverflow</span> <span class="o">=</span> <span class="n">nextOverflow</span>
<span class="p">}</span>

<span class="c">// 进行数据桶数据迁移，将数据迁移到新桶中</span>
<span class="c">// 将一个旧桶中的数据分流到两个新桶，所以它会创建两个用于保存分配上下文的 runtime.evacDst 结构体，这两个结构体分别指向了一个新桶：</span>
<span class="c">// map 扩容函数</span>
<span class="k">func</span> <span class="n">evacuate</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">maptype</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span><span class="n">hmap</span><span class="p">,</span> <span class="n">oldbucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 定位老的 bucket 地址</span>
	<span class="n">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="n">bmap</span><span class="p">)(</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">oldbuckets</span><span class="p">,</span> <span class="n">oldbucket</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">bucketsize</span><span class="p">)))</span>
	<span class="c">// 结果是 2^B，如 B = 5，结果为32</span>
	<span class="n">newbit</span> <span class="o">:=</span> <span class="n">h</span><span class="o">.</span><span class="n">noldbuckets</span><span class="p">()</span>
	<span class="c">// key 的哈希函数</span>
	<span class="n">alg</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">alg</span>
	<span class="c">// 如果 b 没有被搬迁过--执行数据搬迁</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">evacuated</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">var</span> <span class="p">(</span>
			<span class="c">// 表示bucket 移动的目标地址</span>
			<span class="n">x</span><span class="p">,</span> <span class="n">y</span>   <span class="o">*</span><span class="n">bmap</span>
			<span class="c">// 指向 x,y 中的 key/val</span>
			<span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="kt">int</span>
			<span class="c">// 指向 x，y 中的 key</span>
			<span class="n">xk</span><span class="p">,</span> <span class="n">yk</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
			<span class="c">// 指向 x，y 中的 value</span>
			<span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span>
		<span class="p">)</span>
		<span class="c">// 默认是等 size 扩容，前后 bucket 序号不变</span>
		<span class="c">// 使用 x 来进行搬迁</span>
		<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">bmap</span><span class="p">)(</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">buckets</span><span class="p">,</span> <span class="n">oldbucket</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">bucketsize</span><span class="p">)))</span>
		<span class="n">xi</span> <span class="o">=</span> <span class="m">0</span>
		<span class="n">xk</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">dataOffset</span><span class="p">)</span>
		<span class="n">xv</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">bucketCnt</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">keysize</span><span class="p">))</span><span class="err">、</span>

		<span class="c">// 如果不是等 size 扩容，前后 bucket 序号有变</span>
		<span class="c">// 使用 y 来进行搬迁</span>
		<span class="k">if</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="n">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="c">// y 代表的 bucket 序号增加了 2^B</span>
			<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">bmap</span><span class="p">)(</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">buckets</span><span class="p">,</span> <span class="p">(</span><span class="n">oldbucket</span><span class="o">+</span><span class="n">newbit</span><span class="p">)</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">bucketsize</span><span class="p">)))</span>
			<span class="n">yi</span> <span class="o">=</span> <span class="m">0</span>
			<span class="n">yk</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">dataOffset</span><span class="p">)</span>
			<span class="n">yv</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">yk</span><span class="p">,</span> <span class="n">bucketCnt</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">keysize</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="c">// 遍历所有的 bucket，包括 overflow buckets</span>
		<span class="c">// b 是老的 bucket 地址</span>
		<span class="k">for</span> <span class="p">;</span> <span class="n">b</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">overflow</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">k</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">dataOffset</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">:=</span> <span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bucketCnt</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">keysize</span><span class="p">))</span>

			<span class="c">// 遍历 bucket 中的所有 cell</span>
			<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucketCnt</span><span class="p">;</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">keysize</span><span class="p">)),</span> <span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">valuesize</span><span class="p">))</span> <span class="p">{</span>
				<span class="c">// 当前 cell 的 top hash 值</span>
				<span class="n">top</span> <span class="o">:=</span> <span class="n">b</span><span class="o">.</span><span class="n">tophash</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
				<span class="c">// 如果 cell 为空，即没有 key</span>
				<span class="k">if</span> <span class="n">top</span> <span class="o">==</span> <span class="n">empty</span> <span class="p">{</span>
					<span class="c">// 那就标志它被"搬迁"过</span>
					<span class="n">b</span><span class="o">.</span><span class="n">tophash</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">evacuatedEmpty</span>
					<span class="c">// 继续下个 cell</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="c">// 正常不会出现这种情况</span>
				<span class="c">// 未被搬迁的 cell 只可能是 empty 或是</span>
				<span class="c">// 正常的 top hash（大于 minTopHash）</span>
				<span class="k">if</span> <span class="n">top</span> <span class="o">&lt;</span> <span class="n">minTopHash</span> <span class="p">{</span>
					<span class="n">throw</span><span class="p">(</span><span class="s">"bad map state"</span><span class="p">)</span>
				<span class="p">}</span>

				<span class="n">k2</span> <span class="o">:=</span> <span class="n">k</span>
				<span class="c">// 如果 key 是指针，则解引用</span>
				<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">indirectkey</span> <span class="p">{</span>
					<span class="n">k2</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">k2</span><span class="p">))</span>
				<span class="p">}</span>

				<span class="c">// 默认使用 X，等量扩容</span>
				<span class="n">useX</span> <span class="o">:=</span> <span class="no">true</span>
				<span class="c">// 如果不是等量扩容</span>
				<span class="k">if</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="n">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
					<span class="c">// 计算 hash 值，和 key 第一次写入时一样</span>
					<span class="n">hash</span> <span class="o">:=</span> <span class="n">alg</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hash0</span><span class="p">))</span>

					<span class="c">// 如果有协程正在遍历 map</span>
					<span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">iterator</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
						<span class="c">// 如果出现 相同的 key 值，算出来的 hash 值不同</span>
						<span class="k">if</span> <span class="o">!</span><span class="n">t</span><span class="o">.</span><span class="n">reflexivekey</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">alg</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="p">{</span>
							<span class="c">// 只有在 float 变量的 NaN() 情况下会出现</span>
							<span class="k">if</span> <span class="n">top</span><span class="o">&amp;</span><span class="m">1</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
								<span class="c">// 第 B 位置 1</span>
								<span class="n">hash</span> <span class="o">|=</span> <span class="n">newbit</span>
							<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
								<span class="c">// 第 B 位置 0</span>
								<span class="n">hash</span> <span class="o">&amp;^=</span> <span class="n">newbit</span>
							<span class="p">}</span>
							<span class="c">// 取高 8 位作为 top hash 值</span>
							<span class="n">top</span> <span class="o">=</span> <span class="kt">uint8</span><span class="p">(</span><span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">PtrSize</span><span class="o">*</span><span class="m">8</span> <span class="o">-</span> <span class="m">8</span><span class="p">))</span>
							<span class="k">if</span> <span class="n">top</span> <span class="o">&lt;</span> <span class="n">minTopHash</span> <span class="p">{</span>
								<span class="n">top</span> <span class="o">+=</span> <span class="n">minTopHash</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>

					<span class="c">// 取决于新哈希值的 oldB+1 位是 0 还是 1</span>
					<span class="c">// 详细看后面的文章</span>
					<span class="n">useX</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&amp;</span><span class="n">newbit</span> <span class="o">==</span> <span class="m">0</span>
				<span class="p">}</span>

				<span class="c">// 如果 key 搬到 X 部分</span>
				<span class="k">if</span> <span class="n">useX</span> <span class="p">{</span>
					<span class="c">// 标志老的 cell 的 top hash 值，表示搬移到 X 部分</span>
					<span class="n">b</span><span class="o">.</span><span class="n">tophash</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">evacuatedX</span>
					<span class="c">// 如果 xi 等于 8，说明要溢出了</span>
					<span class="k">if</span> <span class="n">xi</span> <span class="o">==</span> <span class="n">bucketCnt</span> <span class="p">{</span>
						<span class="c">// 新建一个 bucket</span>
						<span class="n">newx</span> <span class="o">:=</span> <span class="n">h</span><span class="o">.</span><span class="n">newoverflow</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
						<span class="n">x</span> <span class="o">=</span> <span class="n">newx</span>
						<span class="c">// xi 从 0 开始计数</span>
						<span class="n">xi</span> <span class="o">=</span> <span class="m">0</span>
						<span class="c">// xk 表示 key 要移动到的位置</span>
						<span class="n">xk</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">dataOffset</span><span class="p">)</span>
						<span class="c">// xv 表示 value 要移动到的位置</span>
						<span class="n">xv</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">bucketCnt</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">keysize</span><span class="p">))</span>
					<span class="p">}</span>
					<span class="c">// 设置 top hash 值</span>
					<span class="n">x</span><span class="o">.</span><span class="n">tophash</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">top</span>
					<span class="c">// key 是指针</span>
					<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">indirectkey</span> <span class="p">{</span>
						<span class="c">// 将原 key（是指针）复制到新位置</span>
						<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">xk</span><span class="p">)</span> <span class="o">=</span> <span class="n">k2</span> <span class="c">// copy pointer</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="c">// 将原 key（是值）复制到新位置</span>
						<span class="n">typedmemmove</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="c">// copy value</span>
					<span class="p">}</span>
					<span class="c">// value 是指针，操作同 key</span>
					<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">indirectvalue</span> <span class="p">{</span>
						<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">xv</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">v</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">typedmemmove</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
					<span class="p">}</span>

					<span class="c">// 定位到下一个 cell</span>
					<span class="n">xi</span><span class="o">++</span>
					<span class="n">xk</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">keysize</span><span class="p">))</span>
					<span class="n">xv</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">valuesize</span><span class="p">))</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c">// key 搬到 Y 部分，操作同 X 部分</span>
					<span class="c">// ……</span>
					<span class="c">// 省略了这部分，操作和 X 部分相同</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c">// 如果没有协程在使用老的 buckets，就把老 buckets 清除掉，帮助gc</span>
		<span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">oldIterator</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">bmap</span><span class="p">)(</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">oldbuckets</span><span class="p">,</span> <span class="n">oldbucket</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">bucketsize</span><span class="p">)))</span>
			<span class="c">// 只清除bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态</span>
			<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">bucket</span><span class="o">.</span><span class="n">kind</span><span class="o">&amp;</span><span class="n">kindNoPointers</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
				<span class="n">memclrHasPointers</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">dataOffset</span><span class="p">),</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">bucketsize</span><span class="p">)</span><span class="o">-</span><span class="n">dataOffset</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">memclrNoHeapPointers</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">dataOffset</span><span class="p">),</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">bucketsize</span><span class="p">)</span><span class="o">-</span><span class="n">dataOffset</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c">// 更新搬迁进度</span>
	<span class="c">// 如果此次搬迁的 bucket 等于当前进度</span>
	<span class="k">if</span> <span class="n">oldbucket</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span> <span class="p">{</span>
		<span class="c">// 进度加 1</span>
		<span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span> <span class="o">=</span> <span class="n">oldbucket</span> <span class="o">+</span> <span class="m">1</span>
		<span class="c">// Experiments suggest that 1024 is overkill by at least an order of magnitude.</span>
		<span class="c">// Put it in there as a safeguard anyway, to ensure O(1) behavior.</span>
		<span class="c">// 尝试往后看 1024 个 bucket</span>
		<span class="n">stop</span> <span class="o">:=</span> <span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span> <span class="o">+</span> <span class="m">1024</span>
		<span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">newbit</span> <span class="p">{</span>
			<span class="n">stop</span> <span class="o">=</span> <span class="n">newbit</span>
		<span class="p">}</span>
		<span class="c">// 寻找没有搬迁的 bucket</span>
		<span class="k">for</span> <span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span> <span class="o">!=</span> <span class="n">stop</span> <span class="o">&amp;&amp;</span> <span class="n">bucketEvacuated</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span><span class="o">++</span>
		<span class="p">}</span>
		
		<span class="c">// 现在 h.nevacuate 之前的 bucket 都被搬迁完毕</span>
		
		<span class="c">// 所有的 buckets 搬迁完毕</span>
		<span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">nevacuate</span> <span class="o">==</span> <span class="n">newbit</span> <span class="p">{</span>
			<span class="c">// 清除老的 buckets</span>
			<span class="n">h</span><span class="o">.</span><span class="n">oldbuckets</span> <span class="o">=</span> <span class="no">nil</span>
			<span class="c">// 清除老的 overflow bucket</span>
			<span class="c">// 回忆一下：[0] 表示当前 overflow bucket</span>
			<span class="c">// [1] 表示 old overflow bucket</span>
			<span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">extra</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">h</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">overflow</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="no">nil</span>
			<span class="p">}</span>
			<span class="c">// 清除正在扩容的标志位</span>
			<span class="n">h</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;^=</span> <span class="n">sameSizeGrow</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，扩容过程不是原子的，而是通过 runtime.growWork 增量触发的，</li>
  <li>在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流。</li>
  <li>除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 sameSizeGrow 这一机制，在出现较多溢出桶时会整理哈希的内存减少空间的占用。</li>
</ul>

<p><strong>扩容流程</strong></p>
<ol>
  <li>使用<code class="language-plaintext highlighter-rouge">hashGrow</code> 进行新buckets分配。将老buckets挂载到<code class="language-plaintext highlighter-rouge">oldbuckets</code>。读取时直接从oldbuckets进行数据读取。</li>
  <li>写入/删除时：因为<code class="language-plaintext highlighter-rouge">oldbuckets</code>存在，触发<code class="language-plaintext highlighter-rouge">evacuate</code>开始进行数据复制–这里每次均只进行一次同搬迁</li>
  <li>根据扩容类型：存在数据扩容时，key进行重hash，将数据和元素拷贝到新的bucket中</li>
  <li>清除<code class="language-plaintext highlighter-rouge">overflow bucket</code>, 让其被GC回收</li>
  <li>检查<code class="language-plaintext highlighter-rouge">oldbuckets</code>数据是否都被清除，清除完成。将<code class="language-plaintext highlighter-rouge">oldbuckets</code>设置为nil。方便进行GC回收</li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://qcrao91.gitbook.io/go/map/map-de-kuo-rong-guo-cheng-shi-zen-yang-de">map 的扩容过程是怎样的</a>;<a href="https://www.getcoder.cn/archives/-jin-jie-golang-zhong-map-de-shu-ju-jie-gou-shi-shen-me--shi-zen-me-shi-xian-kuo-rong-">进阶】Golang中map的数据结构是什么？是怎么实现扩容？</a>;<a href="https://blog.csdn.net/qq_44577070/article/details/129770410">Go｜map底层实现、扩容规则、特性</a>;<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#%E6%89%A9%E5%AE%B9">Go Map 扩容</a>
</li>
</ul>

<h2 id="gmp相关">GMP相关</h2>

<h3 id="1-什么是-gmp必问">1. 什么是 GMP？（必问）</h3>

<p>GMP模型是go 调度器的核心模型，go 通过g,m,p的基础结构体实现<code class="language-plaintext highlighter-rouge">goroutine</code> 的调度。同时包含全局可运行队列（GRQ）和本地可运行队列（LRQ）。 LRQ 存储本地（也就是具体的 P）的可运行 goroutine，GRQ 存储全局的可运行 goroutine，这些 goroutine 还没有分配到具体的 P。</p>

<p><img src="https://ask.qcloudimg.com/http-save/yehe-6900791/c781d4d1154dc4c38b02064888e6927b.png" alt="基础模式"></p>

<p><img src="https://golang.design/go-questions/sched/assets/9.png" alt="GMP模型"></p>

<p>G：goroutine 协程，是用户态的轻量级线程。为go中为有栈协程，会保存 CPU 寄存器的值
M: machine 表示系统线程。
P: processor 处理器上下文用于连接G和P，数量默认等于开机器的cpu核心数，若想调小，可以通过 GOMAXPROCS 这个环境变量设置。</p>

<p>M 会从与它绑定的 P 的本地队列获取可运行的 G，也会从 network poller 里获取可运行的 G，还会从其他 P 偷 G。</p>

<p>其关系图片如下：</p>

<p><img src="https://golang.design/go-questions/sched/assets/14.png" alt="GPM关系"></p>

<p><img src="https://img.draveness.me/2020-02-02-15805792666185-go-numa-scheduler-architecture.png" alt="GPM关系图"></p>

<hr>

<ul>
  <li>参考：<a href="https://golang.design/go-questions/sched/gpm/">GPM是什么</a>;<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">go 调度器</a>;<a href="https://go-interview.iswbm.com/c02/c02_07.html">说一下 GMP 模型的原理</a>
</li>
</ul>

<h3 id="2-进程-线程-协程有什么区别">2. 进程. 线程. 协程有什么区别？</h3>

<p>详见：<a href="https://wangpengcheng.github.io/2019/12/17/baidu_interview_prepare/#418-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%8F%E7%A8%8B">协程与线程区别</a></p>

<h3 id="3-抢占式调度是如何抢占的">3. 抢占式调度是如何抢占的？</h3>

<h4 id="31-基于协作的抢占式调度">3.1 基于协作的抢占式调度</h4>

<p>Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。主要工作原理如下：</p>

<ol>
  <li>编译器会在调用函数前插入 <code class="language-plaintext highlighter-rouge">runtime.morestack</code>；</li>
  <li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 <code class="language-plaintext highlighter-rouge">Goroutine</code> 运行超过 10ms 时发出抢占请求 <code class="language-plaintext highlighter-rouge">StackPreempt</code>；</li>
  <li>当发生函数调用时，可能会执行编译器插入的 <code class="language-plaintext highlighter-rouge">runtime.morestack</code>，它调用的 <code class="language-plaintext highlighter-rouge">runtime.newstack</code> 会检查 Goroutine 的 <code class="language-plaintext highlighter-rouge">stackguard0</code> 字段是否为 <code class="language-plaintext highlighter-rouge">StackPreempt</code>;</li>
  <li>如果 <code class="language-plaintext highlighter-rouge">stackguard0</code> 是 <code class="language-plaintext highlighter-rouge">StackPreempt</code>，就会触发抢占让出当前线程；</li>
</ol>

<h4 id="32-基于信号的抢占式调度">3.2 基于信号的抢占式调度</h4>

<p><img src="https://ask.qcloudimg.com/http-save/yehe-6900791/3bde101235263c6efc7f4f52464b7246.png" alt=""></p>

<p>Goroutine 在 system call 和 channel call 时都可能发生阻塞，当程序发生 system call，M 会发生阻塞，同时唤起（或创建）一个新的 M 继续执行其他的 G</p>

<p>当程序发起一个 channel call，程序可能会阻塞，但不会阻塞 M,G 的状态会设置为 waiting，M 继续执行其他的 G, 当 G 的调用完成，会有一个可用的 M 继续执行它</p>

<p>整体抢占逻辑如下：</p>
<ol>
  <li>M1 发送中断信号（signalM(mp, sigPreempt)）</li>
  <li>M2 收到信号，操作系统中断其执行代码，并切换到信号处理函数（sighandler(signum, info, ctxt, gp)）</li>
  <li>M2 修改执行的上下文，并恢复到修改后的位置（asyncPreempt）</li>
  <li>重新进入调度循环进而调度其他 Goroutine（preemptPark 和 gopreempt_m）</li>
</ol>

<p>主要处理流程如下：</p>

<ol>
  <li>程序启动时，在 <code class="language-plaintext highlighter-rouge">runtime.sighandler</code> 中注册 <code class="language-plaintext highlighter-rouge">SIGURG</code> 信号的处理函数 <code class="language-plaintext highlighter-rouge">runtime.doSigPreempt</code>；</li>
  <li>在触发垃圾回收的栈扫描时会调用 <code class="language-plaintext highlighter-rouge">runtime.suspendG</code> 挂起 <code class="language-plaintext highlighter-rouge">Goroutine</code>，该函数会执行下面的逻辑：
    <ol>
      <li>将 <code class="language-plaintext highlighter-rouge">_Grunning</code> 状态的 <code class="language-plaintext highlighter-rouge">Goroutine</code> 标记成可以被抢占，即将 <code class="language-plaintext highlighter-rouge">preemptStop</code> 设置成 true；</li>
      <li>调用 <code class="language-plaintext highlighter-rouge">runtime.preemptM</code> 触发抢占；</li>
    </ol>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">runtime.preemptM</code> 会调用 <code class="language-plaintext highlighter-rouge">runtime.signalM</code> 向线程发送信号 <code class="language-plaintext highlighter-rouge">SIGURG</code>；</li>
  <li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 <code class="language-plaintext highlighter-rouge">runtime.doSigPreempt</code>；</li>
  <li>
<code class="language-plaintext highlighter-rouge">runtime.doSigPreempt</code> 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用<code class="language-plaintext highlighter-rouge">runtime.sigctxt.pushCall</code>；</li>
  <li>
<code class="language-plaintext highlighter-rouge">runtime.sigctxt.pushCall</code> 会修改寄存器并在程序回到用户态时执行 <code class="language-plaintext highlighter-rouge">runtime.asyncPreempt</code>；</li>
  <li>汇编指令 <code class="language-plaintext highlighter-rouge">runtime.asyncPreempt</code> 会调用运行时函数 <code class="language-plaintext highlighter-rouge">runtime.asyncPreempt2</code>；</li>
  <li>
<code class="language-plaintext highlighter-rouge">runtime.asyncPreempt2</code> 会调用 <code class="language-plaintext highlighter-rouge">runtime.preemptPark</code>；</li>
  <li>
<code class="language-plaintext highlighter-rouge">runtime.preemptPark</code> 会修改当前 Goroutine 的状态到 _Gpreempted 并调用 <code class="language-plaintext highlighter-rouge">runtime.schedule</code> 让当前函数陷入休眠并让出线程，调度器会选择其它的 <code class="language-plaintext highlighter-rouge">Goroutine</code> 继续执行；</li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#%e6%8a%a2%e5%8d%a0%e5%bc%8f%e8%b0%83%e5%ba%a6%e5%99%a8">抢占式调度器</a>;<a href="https://golang.design/go-questions/sched/work-steal/">工作窃取</a>;<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.5.html">抢占式调度</a>;<a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/#682-">抢占式调度</a>
</li>
</ul>

<h3 id="4-m-和-p-的数量问题">4. M 和 P 的数量问题？</h3>

<p>M：Thread，也就是操作系统线程，go runtime 最多允许创建 10000 个操作系统线程，超过了就会抛出异常。最多只会有 GOMAXPROCS 个活跃线程能够正常运行</p>

<p>P：Processor，处理器，数量默认等于开机器的cpu核心数，若想调小，可以通过 GOMAXPROCS 这个环境变量设置。</p>

<h3 id="5-goroutine-调度时机有哪些">5. goroutine 调度时机有哪些?</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">情形</th>
      <th style="text-align: left">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">使用关键字<code class="language-plaintext highlighter-rouge">go</code>
</td>
      <td style="text-align: left">go 创建一个新的 goroutine，Go scheduler 会考虑调度</td>
    </tr>
    <tr>
      <td style="text-align: center">GC</td>
      <td style="text-align: left">由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存</td>
    </tr>
    <tr>
      <td style="text-align: center">系统调用</td>
      <td style="text-align: left">当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来</td>
    </tr>
    <tr>
      <td style="text-align: center">内存同步访问</td>
      <td style="text-align: left">atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行</td>
    </tr>
  </tbody>
</table>

<hr>

<ul>
  <li>参考：<a href="https://golang.design/go-questions/sched/when/">goroutine 调度时机有哪些</a>
</li>
</ul>

<h2 id="锁相关">锁相关</h2>

<h3 id="1-除了-mutex-以外还有那些方式安全读写共享变量">1. 除了 mutex 以外还有那些方式安全读写共享变量？</h3>

<ol>
  <li>Channel: 使用channel 来进行消息发送，来读写共享变量。channel 本身就使用了mutex。保证线程安全</li>
  <li>读写锁：使用读写锁可以有效进行变量共享</li>
  <li>原子操作：使用<code class="language-plaintext highlighter-rouge">atomic</code> 包中的数值和bool 类型，可以使用原子操作读写共享变量。但是需要注意操作顺序问题</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">sharedVar</span> <span class="kt">int32</span>

<span class="c">// Writer</span>
<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">atomic</span><span class="o">.</span><span class="n">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sharedVar</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
<span class="p">}()</span>

<span class="c">// Reader</span>
<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">atomic</span><span class="o">.</span><span class="n">LoadInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sharedVar</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div></div>
<ol>
  <li>sync.Once：如果你的共享变量只需要被初始化一次，那么可以使用sync.Once来确保初始化的并发安全性。</li>
  <li>内存屏障：go语言中可以使用<code class="language-plaintext highlighter-rouge">sync.MemoryBarrier</code>设置内存屏障</li>
  <li>sync.WaitGroup: 使用等待信号，也可以实现共享变量的读写</li>
</ol>

<hr>

<ul>
  <li>
<a href="https://www.iamshuaidi.com/23382.html">Golang中除了加Mutex锁以外还有哪些方式可以安全读写共享变量？</a>;<a href="https://www.cnblogs.com/dojo-lzz/p/16183006.html">一文读懂原子操作、内存屏障、锁(偏向锁、轻量级锁、重量级锁、自旋锁)、Disruptor、Go Context之上半部分</a>;<a href="https://www.qiyacloud.cn/2020/12/2020-12-28-0/">Go 并发编程核心篇 —— 内存可见性</a>
</li>
</ul>

<h3 id="2-go-如何实现原子操作">2. Go 如何实现原子操作？</h3>

<p>go中的原子操作，主要是通过CAS CPU原子性指令来实现。CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。</p>

<p>原子操作由底层硬件支持，而锁则由操作系统的调度器实现。锁应当用来保护一段逻辑，对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势，如果要更新的是一个复合对象，则应当使用atomic.Value封装好的实现。</p>

<p>__</p>

<ul>
  <li>参考：<a href="https://www.cnblogs.com/ricklz/p/13648859.html">Go语言的原子操作atomic</a>
</li>
</ul>

<h3 id="3-mutex-是悲观锁还是乐观锁悲观锁-乐观锁是什么">3. Mutex 是悲观锁还是乐观锁？悲观锁. 乐观锁是什么？</h3>

<p>mutex 是悲观锁，会在一开始就尝试进行锁的持有。但是go为了防止最多个锁抢占导致的饿死现象，设置了饥饿模式。当线程最后一个进入时，进入到饥饿模式中。</p>

<p><strong>加锁流程</strong>
互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p>

<ul>
  <li>如果互斥锁处于初始化状态，会通过置位 mutexLocked 加锁；</li>
  <li>如果互斥锁处于 mutexLocked 状态并且在普通模式下工作，会进入自旋，执行 30 次 PAUSE 指令消耗 CPU 时间等待锁的释放；</li>
  <li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
  <li>互斥锁在正常情况下会通过 runtime.sync_runtime_SemacquireMutex 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li>
  <li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li>
</ul>

<p><strong>解锁流程</strong></p>

<p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p>

<ul>
  <li>当互斥锁已经被解锁时，调用 sync.Mutex.Unlock 会直接抛出异常；</li>
  <li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 mutexLocked 标志位；</li>
  <li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 sync.runtime_Semrelease 唤醒对应的 Goroutine；</li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://zhuanlan.zhihu.com/p/40211594">面试必备之乐观锁与悲观锁</a>;<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">go同步原语</a>
</li>
</ul>

<h3 id="4-mutex-有几种模式">4. Mutex 有几种模式？</h3>
<p>mutex 有两种模式，普通模式与饥饿模式</p>
<ul>
  <li>普通模式：正常进行锁的持有与释放的模式，锁的等待者会按照先进先出的顺序获取锁。没有获取到锁的协程会尝试自旋等待。</li>
  <li>饥饿模式：一旦协程超过1ms没有获取到锁，就切换到饥饿模式。让新的协程直接在队列末尾等待，防止其自旋导致资源浪费。同时锁释放后也会直接将锁移交给下一个协程，避免重复释放和加锁，导致性能损耗</li>
</ul>

<p>饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p>

<h3 id="5-goroutine-的自旋占用资源如何解决">5. goroutine 的自旋占用资源如何解决</h3>

<p>自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。</p>

<p>自旋条件：</p>

<ol>
  <li>锁已被占用，并且锁不处于饥饿模式。</li>
  <li>积累的自旋次数小于最大自旋次数（active_spin=4）。</li>
  <li>CPU 核数大于 1。</li>
  <li>有空闲的 P。</li>
  <li>当前 Goroutine 所挂载的 P 下，本地待运行队列为空。</li>
</ol>

<p>mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。</p>

<hr>

<ul>
  <li>参考：<a href="https://www.kancloud.cn/lyj18810711213/golang/3027774#goroutine__50">goroutine 的自旋占用资源如何解决？</a>
</li>
</ul>

<h3 id="6-syncpool-有什么作用">6. sync.Pool 有什么作用</h3>

<p>对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频 繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛 刺。而 sync.Pool 可以将暂时将不用的对象缓存起来，待下次需要的时候直 接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系 统的性能。</p>

<hr>

<ul>
  <li>参考：<a href="https://www.kancloud.cn/lyj18810711213/golang/3027774#syncPool__61">sync.Pool 有什么用</a>
</li>
</ul>

<h3 id="7-rwmutex-实现-与使用注意">7. RWMutex 实现 与使用注意</h3>

<p><strong>RWMutex实现</strong>
RWMutex 主要通过Mutex的封装进行实现，其主要结构体如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">RWMutex</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">w</span>           <span class="n">Mutex</span>    <span class="c">// 统一写锁</span>
	<span class="n">writerSem</span>   <span class="kt">uint32</span>   <span class="c">// 写等待信号</span>
	<span class="n">readerSem</span>   <span class="kt">uint32</span>   <span class="c">// 读等待信号</span>
	<span class="n">readerCount</span> <span class="kt">int32</span>    <span class="c">// 当前正在执行的读操作统计</span>
	<span class="n">readerWait</span>  <span class="kt">int32</span>    <span class="c">// 当写操作被阻塞时等待的读操作个数；</span>
<span class="p">}</span>

<span class="c">// 写锁</span>
<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 1. 持有写锁</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="c">// 2. 阻塞读操作</span>
    <span class="c">// 2.1 将读者设置为负数--避免新增读者</span>
    <span class="c">// 2.2 统计当前读者数量</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="n">rwmutexMaxReaders</span><span class="p">)</span> <span class="o">+</span> <span class="n">rwmutexMaxReaders</span>
    <span class="c">// 3. 存在其它正在读的--等待其释放</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerWait</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// 等待writerSem信号将其唤醒</span>
		<span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">writerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c">// 成功持有返回</span>
<span class="p">}</span>

<span class="c">// 解除写锁</span>
<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 函数将 readerCount 变回正数，释放读锁；</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="n">rwmutexMaxReaders</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">rwmutexMaxReaders</span> <span class="p">{</span>
		<span class="n">throw</span><span class="p">(</span><span class="s">"sync: Unlock of unlocked RWMutex"</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c">// 遍历读者</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c">// 发送信号，唤醒对应读者</span>
        <span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>


<span class="c">// 读锁</span>
<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RLock</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 当前读者数++&amp;&amp;检查是否存在写者</span>
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// 为负数表示存在写入，需要等待锁释放</span>
        <span class="c">// 休眠等待读锁信号</span>
		<span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 解除读锁</span>
<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RUnlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 减少读者数目</span>
	<span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">);</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="c">// 返回负数 — 其他 Goroutine 获得了写锁</span>
        <span class="c">// 进行读锁慢释放</span>
        <span class="n">rw</span><span class="o">.</span><span class="n">rUnlockSlow</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">rUnlockSlow</span><span class="p">(</span><span class="n">r</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">r</span><span class="o">+</span><span class="m">1</span> <span class="o">==</span> <span class="m">0</span> <span class="o">||</span> <span class="n">r</span><span class="o">+</span><span class="m">1</span> <span class="o">==</span> <span class="o">-</span><span class="n">rwmutexMaxReaders</span> <span class="p">{</span>
		<span class="n">throw</span><span class="p">(</span><span class="s">"sync: RUnlock of unlocked RWMutex"</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c">// 减少读者等待数 &amp;&amp; 判断是否没有读者</span>
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerWait</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// 唤醒写者进行工作</span>
		<span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">writerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>虽然读写互斥锁 sync.RWMutex 提供的功能比较复杂，但是因为它建立在 sync.Mutex 上，所以实现会简单很多。我们总结一下读锁和写锁的关系：</p>

<ul>
  <li>调用 sync.RWMutex.Lock 尝试获取写锁时；
    <ul>
      <li>每次 sync.RWMutex.RUnlock 都会将 readerCount 其减一，当它归零时该 Goroutine 会获得写锁；</li>
      <li>将 readerCount 减少 rwmutexMaxReaders 个数以阻塞后续的读操作；</li>
    </ul>
  </li>
  <li>调用 sync.RWMutex.Unlock 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li>
</ul>

<p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p>

<p><strong>使用注意事项</strong></p>

<ol>
  <li>RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁</li>
  <li>读锁占用的情况下会阻止写，不会阻止读，多个 Goroutine 可以同时获取 读锁</li>
  <li>写锁会阻止其他 Goroutine（无论读和写）进来，整个锁由该 Goroutine 独占</li>
  <li>适用于读多写少的场景</li>
  <li>RWMutex 类型变量的零值是一个未锁定状态的互斥锁</li>
  <li>RWMutex 在首次被使用之后就不能再被拷贝</li>
  <li>RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic</li>
  <li>RWMutex 的一个写锁去锁定临界区的共享资源，如果临界区的共享资源已 被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到解锁</li>
  <li>RWMutex 的读锁不要用于递归调用，比较容易产生死锁</li>
  <li>RWMutex 的锁定状态与特定的 goroutine 没有关联。一个 goroutine 可 以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock）</li>
  <li>写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并 都可以成功锁定读锁</li>
  <li>读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而 被阻塞的 Goroutine，其中等待时间最长的一个 Goroutine 会被唤醒</li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#rwmutex">RWMutex</a>;<a href="https://www.kancloud.cn/lyj18810711213/golang/3027774#syncPool__61">RWMutex 实现</a>
</li>
</ul>

<h2 id="并发相关">并发相关</h2>

<h3 id="1-怎么控制并发数">1. 怎么控制并发数？</h3>

<ol>
  <li>使用<code class="language-plaintext highlighter-rouge">channel</code>: 使用<code class="language-plaintext highlighter-rouge">channel</code>在协程创建时进行阻塞。</li>
  <li>使用协程池：目前有很多第三方库实现了协程池，可以很方便地用来控制协程的并发数量，如:<a href="https://github.com/Jeffail/tunny">Jeffail/tunny</a>,<a href="https://github.com/panjf2000/ants">panjf2000/ants</a>
</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"log"</span>
	<span class="s">"time"</span>

	<span class="s">"github.com/Jeffail/tunny"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 创建一个大小为三的协程池</span>
    <span class="c">// 并定义函数</span>
	<span class="n">pool</span> <span class="o">:=</span> <span class="n">tunny</span><span class="o">.</span><span class="n">NewFunc</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="k">interface</span><span class="p">{})</span> <span class="k">interface</span><span class="p">{}</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
		<span class="k">return</span> <span class="no">nil</span>
	<span class="p">})</span>
    <span class="c">// 关闭对应协程池</span>
	<span class="k">defer</span> <span class="n">pool</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="c">// 将参数i传递给协程池定义好的worker处理</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">pool</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c">// 等待一段时间</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="m">4</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<ol>
  <li>调整系统资源上限：
可以直接调整对应的系统资源的上限
    <ul>
      <li>ulimit：使用 <code class="language-plaintext highlighter-rouge">ulimit -n 999999</code> 调整最大的文件句柄数</li>
      <li>虚拟内存：使用<code class="language-plaintext highlighter-rouge">mkswap /mnt/.swapfile</code> 创建交换分区，增加内存上限</li>
    </ul>
  </li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://geektutu.com/post/hpg-concurrency-control.html">控制协程(goroutine)的并发数量</a>
</li>
</ul>

<h3 id="2-多个-goroutine-对同一个-map-写会-panic异常是否可以用-defer-捕获">2. 多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？</h3>

<p><strong>不能</strong>使用defer 进行recover 捕获</p>

<ul>
  <li>go语言中的错误分为三种：
    <ul>
      <li>error: 常用错误，直接由业务进行处理</li>
      <li>panic: 异常，数组越界、空指针等都会触发panic。也可以由业务代码主动触发。可以被recover 进行捕获</li>
      <li>fatal error : 由系统触发。这类错误一般都是跟系统资源相关的。程序无法从这类错误中恢复正常。如：fatal error 就是无法从系统申请内存。</li>
    </ul>
  </li>
  <li>map 并发读写会触发fatal error
    <ul>
      <li>map会检测是否存在并发写：并发写入时 map panic 捕获意义不大，在Go 1.6 之后直接抛出fatal error</li>
      <li>如果检测到并发写会调用runtime.throw()，无法被recover()，直接GG</li>
      <li>如果要并发写map必须在业务层面上加锁（sync.Mutex或sync.RWMutext）或使用sync.Map等同步容器</li>
    </ul>
  </li>
  <li>无法捕获的异常(throw):
    <ul>
      <li>内存溢出(<code class="language-plaintext highlighter-rouge">runtime: out of memory</code>): alloc调用内存不足时，直接throw</li>
      <li>map并发读写：map的并发读写也会导致throw。避免异常问题难以排查</li>
      <li>内存耗尽(<code class="language-plaintext highlighter-rouge">fatal error: stack overflow</code>): 创建协程过多会导致内存耗尽</li>
      <li>
<code class="language-plaintext highlighter-rouge">go nil</code>: go关键字会检查，传入函数，如果为nil会直接crash。</li>
      <li>永久阻塞：go 检测出没有 goroutine 可以运行了，就会直接将程序 crash 掉</li>
    </ul>
  </li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="n">errorHandler</span><span class="p">()</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="no">true</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"alive"</span><span class="p">)</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="o">*</span><span class="m">1</span><span class="p">)</span>
			<span class="k">select</span> <span class="p">{}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="o">&lt;-</span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// fatal error: all goroutines are asleep - deadlock!</span>
</code></pre></div></div>

<ul>
  <li>可以被捕获的异常：
    <ul>
      <li>数组(slice)下标越界(<code class="language-plaintext highlighter-rouge">index out of range</code>):数组下标越界时，可以正常抛出异常</li>
      <li>空指针异常：常规的空指针异常也会可以被正常捕获</li>
      <li>往已经close的chan中发送数据:</li>
      <li>类型断言错误：</li>
    </ul>
  </li>
</ul>

<hr>

<ul>
  <li>参考: <a href="https://juejin.cn/post/7053109648223633438">Go 并发写map产生错误能够通过recover()恢复吗？</a>;<a href="https://taoshu.in/go/go-map-concurrent-misue.html#google_vignette">Go 语言 map 的并发安全问题</a>;<a href="https://www.cnblogs.com/luozhiyun/p/15585415.html">探究 Go 源码中 panic &amp; recover 有哪些坑？</a>
</li>
</ul>

<h3 id="3-如何优雅的实现一个-goroutine-池百度-手写代码">3. 如何优雅的实现一个 goroutine 池（百度. 手写代码）</h3>

<p>线程池主要包含如下对象：</p>
<ul>
  <li>线程池管理器：线程池的统一管理抽象，包含创建线程、启动线程、调配任务</li>
  <li>执行worker： 主要的工作执行线程、</li>
  <li>工作队列：待处理的函数队列，等待调度处理</li>
  <li>调度进程(非必须)：统一的调度进程，从工作队列中选取对应的任务进行处理</li>
</ul>

<p>主要处理逻辑与核心操作如下：</p>

<ol>
  <li>检查当前 Worker 队列中是否有可用的 Worker，如果有，取出执行当前的 task；</li>
  <li>没有可用的 Worker，判断当前在运行的 Worker 是否已超过该 Pool 的容量：{是 —&gt; 再判断工作池是否为非阻塞模式：[是 ——&gt; 直接返回 nil，否 ——&gt; 阻塞等待直至有 Worker 被放回 Pool]，否 —&gt; 新开一个 Worker（goroutine）处理}；</li>
  <li>每个 Worker 执行完任务之后，放回 Pool 的队列中等待。</li>
</ol>

<p><img src="https://res.strikefreedom.top/static_res/blog/figures/66396519-7ed66e00-ea0c-11e9-9c1a-5ca54bbd61eb.png" alt="核心调度流程"></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">sig</span> <span class="k">struct</span><span class="p">{}</span>
 
<span class="c">// 定义基础执行函数</span>
<span class="k">type</span> <span class="n">f</span> <span class="k">func</span><span class="p">()</span> <span class="kt">error</span>
 
<span class="c">// Pool accept the tasks from client,it limits the total</span>
<span class="c">// of goroutines to a given number by recycling goroutines.</span>
<span class="c">// 协程池</span>
<span class="k">type</span> <span class="n">Pool</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// capacity of the pool.</span>
	<span class="n">capacity</span> <span class="kt">int32</span>  <span class="c">// 支持容量</span>
 
	<span class="c">// running is the number of the currently running goroutines.</span>
	<span class="n">running</span> <span class="kt">int32</span>  <span class="c">// 当前运行的数量</span>
 
	<span class="c">// expiryDuration set the expired time (second) of every worker.</span>
	<span class="n">expiryDuration</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span>  <span class="c">// 每个worker的过期时间</span>
 
	<span class="c">// workers is a slice that store the available workers.</span>
	<span class="n">workers</span> <span class="p">[]</span><span class="o">*</span><span class="n">Worker</span> <span class="c">// 运行队列</span>
 
	<span class="c">// release is used to notice the pool to closed itself.</span>
	<span class="n">release</span> <span class="k">chan</span> <span class="n">sig</span>     <span class="c">// 是否释放</span>
 
	<span class="c">// lock for synchronous operation.</span>
	<span class="n">lock</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span> <span class="c">// 异步锁，用于提交队列</span>
 
	<span class="n">once</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>  <span class="c">// 用于执行一次</span>
<span class="p">}</span>

<span class="c">// NewPool generates a instance of ants pool</span>
<span class="k">func</span> <span class="n">NewPool</span><span class="p">(</span><span class="n">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">Pool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">NewTimingPool</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">DefaultCleanIntervalTime</span><span class="p">)</span>
<span class="p">}</span>
 
<span class="c">// NewTimingPool generates a instance of ants pool with a custom timed task</span>
<span class="k">func</span> <span class="n">NewTimingPool</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">expiry</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">Pool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">ErrInvalidPoolSize</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">expiry</span> <span class="o">&lt;=</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">ErrInvalidPoolExpiry</span>
	<span class="p">}</span>
    <span class="c">// 初始化默认pool </span>
	<span class="n">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Pool</span><span class="p">{</span>
		<span class="n">capacity</span><span class="o">:</span>       <span class="kt">int32</span><span class="p">(</span><span class="n">size</span><span class="p">),</span>
		<span class="n">freeSignal</span><span class="o">:</span>     <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">sig</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxInt32</span><span class="p">),</span>
		<span class="n">release</span><span class="o">:</span>        <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">sig</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span>
		<span class="n">expiryDuration</span><span class="o">:</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">expiry</span><span class="p">)</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span>  <span class="c">// 设置超时时间</span>
	<span class="p">}</span>
	<span class="c">// 启动定期清理过期worker任务，独立goroutine运行，</span>
	<span class="c">// 进一步节省系统资源</span>
	<span class="n">p</span><span class="o">.</span><span class="n">monitorAndClear</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// Submit submit a task to pool</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Pool</span><span class="p">)</span> <span class="n">Submit</span><span class="p">(</span><span class="n">task</span> <span class="n">f</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">release</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ErrPoolClosed</span>
	<span class="p">}</span>
	<span class="n">w</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">getWorker</span><span class="p">()</span>
    <span class="c">// 将任务写入到worker中</span>
	<span class="n">w</span><span class="o">.</span><span class="n">task</span> <span class="o">&lt;-</span> <span class="n">task</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// getWorker returns a available worker to run the tasks.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Pool</span><span class="p">)</span> <span class="n">getWorker</span><span class="p">()</span> <span class="o">*</span><span class="n">Worker</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">w</span> <span class="o">*</span><span class="n">Worker</span>
	<span class="c">// 标志变量，判断当前正在运行的worker数量是否已到达Pool的容量上限</span>
	<span class="n">waiting</span> <span class="o">:=</span> <span class="no">false</span>
	<span class="c">// 加锁，检测队列中是否有可用worker，并进行相应操作</span>
	<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="n">idleWorkers</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">workers</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idleWorkers</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span>
	<span class="c">// 当前队列中无可用worker</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="c">// 判断运行worker数目已达到该Pool的容量上限，置等待标志</span>
		<span class="n">waiting</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">Running</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">.</span><span class="n">Cap</span><span class="p">()</span>
  
	<span class="c">// 当前队列有可用worker，从队列尾部取出一个使用</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">idleWorkers</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
		<span class="n">idleWorkers</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="no">nil</span>
		<span class="n">p</span><span class="o">.</span><span class="n">workers</span> <span class="o">=</span> <span class="n">idleWorkers</span><span class="p">[</span><span class="o">:</span><span class="n">n</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c">// 检测完成，解锁</span>
	<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="c">// Pool容量已满，新请求等待</span>
	<span class="k">if</span> <span class="n">waiting</span> <span class="p">{</span>
		<span class="c">// 利用锁阻塞等待直到有空闲worker</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
			<span class="n">idleWorkers</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">workers</span>
			<span class="n">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idleWorkers</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span>
			<span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
				<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">idleWorkers</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
			<span class="n">idleWorkers</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="no">nil</span>
			<span class="n">p</span><span class="o">.</span><span class="n">workers</span> <span class="o">=</span> <span class="n">idleWorkers</span><span class="p">[</span><span class="o">:</span><span class="n">l</span><span class="p">]</span>
			<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="c">// 当前无空闲worker但是Pool还没有满，</span>
	<span class="c">// 则可以直接新开一个worker执行任务</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">w</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Worker</span><span class="p">{</span>
			<span class="n">pool</span><span class="o">:</span> <span class="n">p</span><span class="p">,</span>
			<span class="n">task</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">f</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span>
		<span class="p">}</span>
		<span class="n">w</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="c">// 运行worker数加一</span>
		<span class="n">p</span><span class="o">.</span><span class="n">incRunning</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">w</span>
<span class="p">}</span>

<span class="c">// worker 回收 </span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Pool</span><span class="p">)</span> <span class="n">putWorker</span><span class="p">(</span><span class="n">worker</span> <span class="o">*</span><span class="n">Worker</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 写入回收时间，亦即该worker的最后一次结束运行的时间</span>
	<span class="n">worker</span><span class="o">.</span><span class="n">recycleTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>
	<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="n">p</span><span class="o">.</span><span class="n">workers</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">workers</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>
	<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// ReSize change the capacity of this pool</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Pool</span><span class="p">)</span> <span class="n">ReSize</span><span class="p">(</span><span class="n">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">Cap</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="n">atomic</span><span class="o">.</span><span class="n">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">capacity</span><span class="p">,</span> <span class="kt">int32</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
	<span class="n">diff</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">Running</span><span class="p">()</span> <span class="o">-</span> <span class="n">size</span>
	<span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">diff</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">.</span><span class="n">getWorker</span><span class="p">()</span><span class="o">.</span><span class="n">task</span> <span class="o">&lt;-</span> <span class="no">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 清理过期worker</span>
<span class="c">// clear expired workers periodically.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Pool</span><span class="p">)</span> <span class="n">periodicallyPurge</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">heartbeat</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">expiryDuration</span><span class="p">)</span>
	<span class="k">for</span> <span class="k">range</span> <span class="n">heartbeat</span><span class="o">.</span><span class="n">C</span> <span class="p">{</span>
		<span class="n">currentTime</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>
		<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
		<span class="n">idleWorkers</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">workers</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idleWorkers</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="n">Running</span><span class="p">()</span> <span class="o">==</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">release</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">:=</span> <span class="m">0</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">idleWorkers</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">currentTime</span><span class="o">.</span><span class="n">Sub</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">recycleTime</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">.</span><span class="n">expiryDuration</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">i</span>
			<span class="n">w</span><span class="o">.</span><span class="n">task</span> <span class="o">&lt;-</span> <span class="no">nil</span>
			<span class="n">idleWorkers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="no">nil</span>
		<span class="p">}</span>
		<span class="n">n</span><span class="o">++</span>
		<span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idleWorkers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">.</span><span class="n">workers</span> <span class="o">=</span> <span class="n">idleWorkers</span><span class="p">[</span><span class="o">:</span><span class="m">0</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">.</span><span class="n">workers</span> <span class="o">=</span> <span class="n">idleWorkers</span><span class="p">[</span><span class="n">n</span><span class="o">:</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">.</span><span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>worker.go</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Worker is the actual executor who runs the tasks,</span>
<span class="c">// it starts a goroutine that accepts tasks and</span>
<span class="c">// performs function calls.</span>
<span class="k">type</span> <span class="n">Worker</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// pool who owns this worker.</span>
	<span class="n">pool</span> <span class="o">*</span><span class="n">Pool</span>
 
	<span class="c">// task is a job should be done.</span>
	<span class="n">task</span> <span class="k">chan</span> <span class="n">f</span>
 
	<span class="c">// recycleTime will be update when putting a worker back into queue.</span>
	<span class="n">recycleTime</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span>
<span class="p">}</span>
 
<span class="c">// run starts a goroutine to repeat the process</span>
<span class="c">// that performs the function calls.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span><span class="n">Worker</span><span class="p">)</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c">// 循环监听任务列表，一旦有任务立马取出运行</span>
		<span class="k">for</span> <span class="n">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">w</span><span class="o">.</span><span class="n">task</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="c">// 退出goroutine，运行worker数减一</span>
				<span class="n">w</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">decRunning</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="n">f</span><span class="p">()</span>
			<span class="c">// worker回收复用</span>
			<span class="n">w</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">putWorker</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
<span class="p">}</span>

</code></pre></div></div>

<hr>

<ul>
  <li>参考: <a href="https://doraemonabcd.xyz/post/ood/how-deisgn-a-goroutine-pool/#%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e4%bc%98%e9%9b%85%e7%9a%84goroutine%e6%b1%a0%e5%ad%90">如何设计一个优雅的goroutine池子</a>;<a href="https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/">C++ 线程池</a>;<a href="https://strikefreedom.top/archives/high-performance-implementation-of-goroutine-pool">高性能协程池</a>
</li>
</ul>

<h3 id="4-go在什么情况下会panic">4. Go在什么情况下会panic</h3>

<p>见的有10种情况：</p>

<ul>
  <li>数组/切片索引越界；</li>
  <li>引用空指针；</li>
  <li>除以零；</li>
  <li>向已经关闭的通道发消息；</li>
  <li>关闭一个已关闭的通道；</li>
  <li>关闭未初始化的通道；</li>
  <li>写入未初始化的map；</li>
  <li>跨协程的panic处理；</li>
  <li>sync计数为负值 ：wg.Add(-1)</li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://juejin.cn/post/7308620787329384499">Go的Panic相关问题</a>
</li>
</ul>

<h2 id="gc相关">GC相关</h2>

<h3 id="1-go-gc-是怎么实现的必问">1. go gc 是怎么实现的？（必问）</h3>

<p>详见：<a href="https://wangpengcheng.github.io/2023/04/17/go_interview/#05-%E7%AE%80%E8%BF%B0-go-%E8%AF%AD%E8%A8%80gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">05 简述 Go 语言GC(垃圾回收)的工作原理</a></p>

<h3 id="2-go-是-gc-算法是怎么实现的-得物出现频率低">2. go 是 gc 算法是怎么实现的？ （得物，出现频率低）</h3>

<p>被称为”并发三色标记清扫”（Concurrent Tri-color Mark and Sweep，简称CTMS）算法。</p>

<p>以下是该算法的基本步骤：</p>

<ol>
  <li>
<strong>标记开始（Mark Start）</strong>：这个阶段会停止所有的Goroutine，这是一个STW（Stop The World）阶段，但该阶段通常非常短。</li>
  <li>
<strong>标记（Mark）</strong>：在这个阶段，GC会从一组根对象（比如全局变量，当前活跃的goroutine的栈变量等）开始，标记所有可以直接或间接访问到的对象。这个阶段是并发的，可以与Goroutine的运行并行进行。</li>
  <li>
<strong>标记终止（Mark Termination）</strong>：这是第二个STW阶段，主要完成一些清理和状态恢复工作。</li>
  <li>
<strong>清扫（Sweep）</strong>：在这个阶段，GC会清扫并回收所有未被标记的对象，即那些在标记阶段确定为不可达的对象。这个阶段也是可以与Goroutine的运行并行进行的。</li>
</ol>

<p>这种GC算法的优点是大部分工作都可以在Goroutine运行的时候并行进行，只有非常短的时间需要停止所有Goroutine，这样可以减少GC对程序性能的影响。同时，Go的GC实现还包含了很多优化措施，比如分代GC、写屏障等，以进一步提高GC的效率。</p>

<p>不过，需要注意的是，尽管Go的GC算法可以并发运行，但它仍然会消耗一些CPU和内存资源，这可能会影响程序的性能。因此，在编写Go程序时，我们仍然应该尽量减少内存分配和垃圾产生的量，以减少GC的负担。</p>

<hr>

<ul>
  <li>参考：<a href="https://www.iamshuaidi.com/23440.html">Go 是 GC 算法是怎么实现的？</a>
</li>
</ul>

<h3 id="3-gc-中-stw-时机各个阶段是如何解决的-百度">3. GC 中 stw 时机，各个阶段是如何解决的？ （百度）</h3>

<p>1）在开始新的一轮 GC 周期前，需要调用 gcWaitOnMark 方法上一轮 GC 的标记结束（含扫描终止、标记、或标记终止等）。</p>

<p>2）开始新的一轮 GC 周期，调用 gcStart 方法触发 GC 行为，开始扫描标记阶段。</p>

<p>3）需要调用 gcWaitOnMark 方法等待，直到当前 GC 周期的扫描、标记、标记终止完成。</p>

<p>4）需要调用 sweepone 方法，扫描未扫除的堆跨度，并持续扫除，保证清理完成。在等待扫除完毕前的阻塞时间，会调用 Gosched 让出。</p>

<p>5）在本轮 GC 已经基本完成后，会调用 mProf_PostSweep 方法。以此记录最后一次标记终止时的堆配置文件快照。</p>

<p>6）结束，释放 M。</p>

<hr>

<ul>
  <li>参考：<a href="https://www.kancloud.cn/lyj18810711213/golang/2747138">GC 中 stw 时机，各个阶段是如何解决的？</a>;<a href="https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.10.GC-GC.md">10. Go 语言中 GC 的流程是什么？</a>
</li>
</ul>

<h3 id="4-gc-的触发时机">4. GC 的触发时机？</h3>

<ol>
  <li>主动触发：调用 runtime.GC</li>
  <li>被动触发：
    <ul>
      <li>使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC时，强制触发 GC。</li>
      <li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例.</li>
    </ul>
  </li>
</ol>

<ul>
  <li>参考：<a href="https://www.kancloud.cn/lyj18810711213/golang/2747138">GC 触发时机</a>;<a href="https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.11.GC-GC.md">11. 触发 GC 的时机是什么？</a>
</li>
</ul>

<h3 id="5-gc-如何调优">5. GC 如何调优</h3>
<p>通过 go tool pprof 和 go tool trace 等工具</p>

<p>控制内存分配的速度，限制 Goroutine 的数量，从而提高赋值器对 CPU 的利用率。
减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例 如提前分配足够的内存来降低多余的拷贝。
需要时，增大 GOGC 的值，降低 GC 的运行频率。</p>

<h2 id="内存相关">内存相关</h2>

<h3 id="1-谈谈内存泄露什么情况下内存会泄露怎么定位排查内存泄漏问题">1. 谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？</h3>

<p><strong>内存泄漏定义</strong></p>

<p>当在Go语言中发生内存泄漏时，通常是因为程序中的某些对象在不再需要时仍然被引用，导致无法被垃圾回收器回收。这可能是因为对象被意外地保留在某个地方，比如缓存中，或者因为某些资源没有被正确释放。</p>

<p>以下是一些可能导致内存泄漏的常见情况：</p>

<ol>
  <li>
    <p>循环引用：如果两个对象相互引用，而且没有其他对象引用它们，那么它们将无法被垃圾回收器回收。比如两个协程共同引用对象，没有释放。</p>
  </li>
  <li>
    <p>未关闭资源：比如文件、网络连接等资源在使用完毕后没有被正确关闭，导致资源泄漏。</p>
  </li>
  <li>
    <p>大对象缓存：如果程序中使用了大对象缓存，而且没有合理地控制缓存的大小或者没有及时清理缓存，就会导致内存泄漏。</p>
  </li>
  <li>
    <p>Goroutine泄漏：如果创建了大量的goroutine，而且这些goroutine没有被正确管理和释放，就会导致内存泄漏。</p>
    <ul>
      <li>申请过多的goroutine：例如在for循环中申请过多的goroutine来不及释放导致内存泄漏。一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的</li>
      <li>goroutine阻塞： 协程阻塞导致内存不能正常进行释放。</li>
      <li>I/O问题： I/O连接未设置超时时间，导致goroutine一直在等待，代码会一直阻塞。</li>
      <li>互斥锁未释放：goroutine无法获取到锁资源，导致goroutine阻塞</li>
      <li>死锁：当程序死锁时其他goroutine也会阻塞</li>
      <li>waitgroup使用不当：waitgroup的Add、Done和wait数量不匹配会导致wait一直在等待。</li>
      <li>time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。</li>
      <li>字符串的截取引发临时性的内存泄漏：</li>
      <li>切片截取引起子切片内存泄漏：</li>
      <li>函数数组传参引发内存泄漏：函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为 100 万，64 位机上消耗的内存约为 800w 字节，即 8MB 内存），或者该函数短时间内被调用 N 次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及 GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕</li>
    </ul>
  </li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">// 字符串截取内存泄漏</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="k">var</span> <span class="n">str0</span> <span class="o">=</span> <span class="s">"12345678901234567890"</span>
 <span class="n">str1</span> <span class="o">:=</span> <span class="n">str0</span><span class="p">[</span><span class="o">:</span><span class="m">10</span><span class="p">]</span>
<span class="p">}</span>

<span class="c">// 切片截取引起子切片内存泄漏</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">var</span> <span class="n">s0</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">7</span><span class="p">,</span><span class="m">8</span><span class="p">,</span><span class="m">9</span><span class="p">}</span>
   <span class="n">s1</span> <span class="o">:=</span> <span class="n">s0</span><span class="p">[</span><span class="o">:</span><span class="m">3</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>内存泄漏排查</strong></p>
<ol>
  <li>pprof排查：可以使用go 内置的pprof进行内存泄漏排查。重点检查高内存占用的路径。</li>
  <li>bcc排查工具：使用中的<code class="language-plaintext highlighter-rouge">memleak</code> 工具进行内存泄漏分析</li>
  <li>使用valgrind：使用其中的<code class="language-plaintext highlighter-rouge">Memcheck</code> 工具，直接进行内存泄漏分析</li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://www.hitzhangjie.pro/blog/2021-04-14-go%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/">Go程序内存泄露问题快速定位</a>;<a href="https://gfw.go101.org/article/memory-leaking.html">一些可能的内存泄漏场景</a>;<a href="https://developer.aliyun.com/article/1353024">No.7 一篇文章讲清楚golang内存泄漏</a>;<a href="https://yuanfentiank789.github.io/2018/11/01/%E7%94%A8Valgrind%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">Valgrind内存泄漏分析</a>;<a href="https://xie.infoq.cn/article/1bf88b039aad3c61af144154c">GO常规问题</a>
</li>
</ul>

<h3 id="2-知道-golang-的内存逃逸吗什么情况下会发生内存逃逸">2. 知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？</h3>

<p>Go 语言中，堆内存是通过垃圾回收机制自动管理的，无需开发者指定。那么，Go 编译器怎么知道某个变量需要分配在栈上，还是堆上呢？编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。</p>

<p>发生内存逃逸的主要情况如下：</p>
<ol>
  <li>指针逃逸：返回对象指针，导致函数内变量内存在堆上分配。</li>
  <li>interface{} 动态类型逃逸：在 Go 语言中，空接口即 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。</li>
  <li>栈空间不足：栈空间较小，函数递归较深。容易导致栈溢出。超过一定大小的局部变量逃逸到堆上。</li>
  <li>闭包：闭包中一个内层函数中访问到其外层函数的作用域。访问共享的变量会发生逃逸。</li>
</ol>

<hr>

<ul>
  <li>参考：<a href="https://geektutu.com/post/hpg-escape-analysis.html">Go 逃逸分析</a>
</li>
</ul>

<h3 id="3-请简述-go-是如何分配内存的">3. 请简述 Go 是如何分配内存的？</h3>

<h4 id="31-内存管理单元">3.1 内存管理单元</h4>
<p>go 内存管理，主要是指 go runtime 中的堆和栈上的内存管理。本质上是自带回收机制的内存池。可以有效降低编码过程中的内存管理新智负担，提高资源利用率。主要通过4种主要内存管理单元实现。其主要内存结构如下：</p>

<p><img src="https://img.draveness.me/2020-02-29-15829868066479-go-memory-layout.png" alt="内存管理单元"></p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">mspan</code>(内存管理基本单元): 内存池单元抽象，包含多个大小为8KB内存块，和对应的Object对象大小，用于快速进行内存申请和分配。
<img src="http://wangpengcheng.github.io/img/2024-03-31_22-33-23.png" alt="对象和page大小">
</li>
  <li>
<code class="language-plaintext highlighter-rouge">mcache</code>(线程缓存):  是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。包含堆对象和栈对象。无需进行锁操作
<img src="https://img.draveness.me/2020-02-29-15829868066512-mcache-and-mspans.png" alt="线程花村">
</li>
  <li>
<code class="language-plaintext highlighter-rouge">mcentral</code>(中心缓存): 内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁。同时内存获取时会<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%8d%95%e5%85%83-1">分为多级</a>内存查询。</li>
  <li>
<code class="language-plaintext highlighter-rouge">mheap</code>(堆内存):内存分配的核心结构体，Go 语言程序会将其作为全局变量存储，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 central，另一个是管理堆区内存区域的 arenas 以及相关字段。
<img src="https://img.draveness.me/2020-02-29-15829868066531-mheap-and-memories.png" alt="runtime.heapArena">
</li>
</ul>

<h4 id="31-内存分配">3.1 内存分配</h4>

<p>go 根据对象占用内存，将其分为了对象、小对象和微对象。不同的对象由不同的层级进行内存分配。</p>

<ul>
  <li>微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li>
  <li>小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li>
  <li>大对象 (32KB, +∞) — 直接在堆上分配内存；</li>
</ul>

<p>对于堆空间而言，主要分配策略如下：</p>

<ul>
  <li>Go语言源代码中「栈内存」和「堆内存」的分配都是虚拟内存，最终CPU在执行指令过程中通过内部的MMU把虚拟内存转化为物理内存。</li>
  <li>Go语言编译期间会进行逃逸分析，判断并标记变量是否需要分配到堆上，比如创建Map、Slice时。</li>
  <li>栈内存分配
    <ul>
      <li>小于32KB的栈内存
        <ul>
          <li>来源优先级1：线程缓存mcache</li>
          <li>来源优先级2：全局缓存stackpool</li>
          <li>来源优先级3：逻辑处理器结构p.pagecache</li>
          <li>来源优先级4：堆mheap</li>
        </ul>
      </li>
      <li>大于等于32KB的栈内存
        <ul>
          <li>来源优先级1：全局缓存stackLarge</li>
          <li>来源优先级2：逻辑处理器结构p.pagecache</li>
          <li>来源优先级3：堆mheap</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>堆内存分配
    <ul>
      <li>微对象 0 &lt; Micro Object &lt; 16B
        <ul>
          <li>来源优先级1：线程缓存mcache.tiny</li>
          <li>来源优先级2：线程缓存mcache.alloc</li>
        </ul>
      </li>
      <li>小对象 16B =&lt; Small Object &lt;= 32KB
        <ul>
          <li>来源优先级1：线程缓存mcache.alloc</li>
          <li>来源优先级2：中央缓存mcentral</li>
          <li>来源优先级3：逻辑处理器结构p.pagecache</li>
          <li>来源优先级4：堆mheap</li>
        </ul>
      </li>
      <li>大对象 32KB &lt; Large Object
        <ul>
          <li>来源优先级1：逻辑处理器结构p.pagecache</li>
          <li>来源优先级2：堆mheap</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>「栈内存」也来源于堆mheap</li>
</ul>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ec2fe4f9054b8295452e697a84eaa1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="栈内存"></p>

<h4 id="32-内存回收策略">3.2 内存回收策略</h4>

<p>详见：<a href="https://wangpengcheng.github.io/2023/04/17/go_interview/#05-%E7%AE%80%E8%BF%B0-go-%E8%AF%AD%E8%A8%80gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">05 简述 Go 语言GC(垃圾回收)的工作原理</a></p>

<hr>

<ul>
  <li>参考：<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">7.1 内存分配器</a>;<a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch07alloc/">go内存分配</a>;<a href="https://juejin.cn/post/7135670650353483783">一文彻底理解Go语言栈内存/堆内存</a>;<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/">7.3 栈空间管理</a>;<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">go垃圾收集器</a>
</li>
</ul>

<h3 id="4-channel-分配在栈上还是堆上哪些对象分配在堆上哪些对象分配在栈上">4. Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？</h3>

<ul>
  <li>
    <p>Channel内存分配： Channel 被设计用来实现协程间通信的组件，其作用域和生命周期不可能仅限于某个函数内部，所以 golang 直接将其分配在堆上。栈上会有对应指针，指向堆内存对象</p>
  </li>
  <li>Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。通常情况下：
    <ul>
      <li>栈上：函数调用的参数、返回值以及小类型局部变量大都会被分配到栈上，这部分内存会由编译器进行管理。 无需 GC 的标记。</li>
      <li>堆上：大对象、逃逸的变量会被分配到堆上，分配到堆上的对象。Go 的运行时 GC 就会在 后台将对应的内存进行标记从而能够在垃圾回收的时候将对应的内存回收，进而增加了开销。</li>
    </ul>
  </li>
  <li>堆栈分配区分：默认都是在栈中进行内存分配。有两种情况会分配在堆上
    <ul>
      <li>栈内存不足：当栈内存不足时，会直接在堆上进行内存分配</li>
      <li>发生逃逸：变量进过逃逸分析后发现，在栈上分配有空指针风险。需要在堆上分配
        <ul>
          <li>
            <ol>
              <li>指针逃逸：返回对象指针，导致函数内变量内存在堆上分配。</li>
            </ol>
          </li>
          <li>
            <ol>
              <li>interface{} 动态类型逃逸：在 Go 语言中，空接口即 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。</li>
            </ol>
          </li>
          <li>
            <ol>
              <li>栈空间不足：栈空间较小，函数递归较深。容易导致栈溢出。超过一定大小的局部变量逃逸到堆上。</li>
            </ol>
          </li>
          <li>
            <ol>
              <li>闭包：闭包中一个内层函数中访问到其外层函数的作用域。访问共享的变量会发生逃逸。</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr>

<ul>
  <li>参考：<a href="https://zhuanlan.zhihu.com/p/523195006">如何判断golang变量是分配在栈（stack）上还是堆（heap）上？</a>
</li>
</ul>

<h3 id="5-介绍一下大对象小对象为什么小对象多了会造成-gc-压力">5. 介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？</h3>

<p>小对象： 小于等于 32k 的对象就是，
大对象： 大于32KB的对象</p>

<p>一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配。</p>

<hr>

<ul>
  <li>参考：<a href="https://xie.infoq.cn/article/1bf88b039aad3c61af144154c">整理 Golang 面试第二篇干货 13 问</a>
</li>
</ul>

<h2 id="算法相关">算法相关</h2>

<h3 id="标准输入问题">标准输入问题</h3>
<ul>
  <li><a href="https://www.nowcoder.com/feed/main/detail/c707c89102eb4fd4b54919546f1a26a4?sourceSSR=search">go标准输入问题</a></li>
</ul>

<p>go 算法题目中需要手动读取程序输入。如何进行正常的标准输入获取。</p>

<h4 id="输入获取方式">输入获取方式：</h4>

<ol>
  <li>fmt.Scan/fmt.Scanln:直接使用Scan 可以方便快速进行多个变量的获取与赋值，但是解析较慢</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">var</span> <span class="n">name</span> <span class="kt">string</span>
    <span class="k">var</span> <span class="n">age</span> <span class="kt">int</span>

    <span class="c">/*
        使用"&amp;"获取score变量的内存地址(即取变量内存地址的运算符)，通过键盘输入为score变量指向的内存地址赋初值。

        fmt.Scan是一个阻塞的函数，如果它获取不到数据就会一直阻塞哟。

        fmt.Scan可以接收多个参数，用户输入参数默认使用空格或者回车换行符分割输入设备传入的参数，直到接收所有的参数为止
    */</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>

    <span class="c">/*
        和fmt.Scan功能类似，fmt.Scanln也是一个阻塞的函数，如果它获取不到数据就会一直阻塞哟。

        fmt.Scanln也可以接收多个参数，用户输入参数默认使用空格分割输入设备传入的参数，遇到回车换行符就结束接收参数
    */</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Scanln</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>

     <span class="c">/*
        和fmt.Scanln功能类似，fmt.Scanf也是一个阻塞的函数，如果它获取不到数据就会一直阻塞哟。

        其实fmt.Scanln和fmt.Scanf可都以接收多个参数，用户输入参数默认使用空格分割输入设备传入的参数，遇到回车换行符就结束接收参数

        唯一区别就是可以格式化用户输入的数据类型,如下所示:
            %s:
                表示接收的参数会被转换成一个字符串类型，赋值给变量
            %d:
                表示接收的参数会被转换成一个整形类型，赋值给变量

        生产环境中使用fmt.Scanln和fmt.Scanf的情况相对较少，一般使用fmt.Scan的情况较多~
    */</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Scanf</span><span class="p">(</span><span class="s">"%s%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>bufio.NewScanner: 获取标准输入即可。但是其最大长度仅有<code class="language-plaintext highlighter-rouge">64 * 1024</code>字节，需要使用bufio.Reader</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"bufio"</span>
    <span class="s">"fmt"</span>
    <span class="s">"os"</span>
    <span class="s">"strconv"</span>
    <span class="s">"strings"</span>
<span class="p">)</span>

<span class="n">input</span> <span class="o">:=</span> <span class="n">bufio</span><span class="o">.</span><span class="n">NewScanner</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdin</span><span class="p">)</span>
<span class="k">for</span> <span class="n">input</span><span class="o">.</span><span class="n">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">:=</span> <span class="n">input</span><span class="o">.</span><span class="n">Text</span><span class="p">()</span>
<span class="p">}</span>   
</code></pre></div></div>

<ol>
  <li>bufio.NewReader: 使用其获取标准输入，但是输入比较原始，需要注意格式解析</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
    <span class="s">"bufio"</span>
    <span class="s">"fmt"</span>
    <span class="s">"os"</span>
<span class="p">)</span>
<span class="k">var</span> <span class="n">inputReader</span> <span class="o">*</span><span class="n">bufio</span><span class="o">.</span><span class="n">Reader</span>
<span class="k">var</span> <span class="n">input</span> <span class="kt">string</span>
<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">inputReader</span> <span class="o">=</span> <span class="n">bufio</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdin</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Please enter some input: "</span><span class="p">)</span>
    <span class="n">input</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">inputReader</span><span class="o">.</span><span class="n">ReadString</span><span class="p">(</span><span class="sc">'S'</span><span class="p">)</span> <span class="c">//func (b *Reader) ReadString(delim byte) (line string, err error) ,‘S’ 这个例子里使用S表示结束符，也可以用其它，如'\n'</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The input was: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// Please enter some input:</span>
<span class="c">// abcd</span>
<span class="c">// </span>
<span class="c">// abc</span>
<span class="c">// S</span>
<span class="c">// The input was: abcd</span>
<span class="c">//</span>
<span class="c">// abc</span>
<span class="c">// S</span>
</code></pre></div></div>

<h4 id="常见场景">常见场景</h4>

<ol>
  <li>多行数据(不知道有几行)，每行固定个数，空格隔开</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"io"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="n">io</span><span class="o">.</span><span class="n">EOF</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c">// input</span>
<span class="c">// 1 2</span>
<span class="c">// 1 2</span>
<span class="c">// out </span>
<span class="c">// 3</span>
<span class="c">// 3</span>
</code></pre></div></div>

<ol>
  <li>场景2：多行数据，第一行只有一个数字n，表示后面的行数，其他每行固定个数</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>场景3：输入数据有多行，每行固定个数，读取到特殊数据(如0,0)时停止</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<ol>
  <li>场景4：输入数据有多行，每行第一个数字指定当前行数据个数，读取到特殊数据时停止</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="n">sum</span> <span class="o">:=</span> <span class="m">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<ol>
  <li>多行不定数据输入</li>
</ol>

<p>输入数据有多组, 每行表示一组输入数据。
每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。
接下来n个正整数。
不知道总共有多少行数据。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"io"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c">// 读取首行n</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="n">io</span><span class="o">.</span><span class="n">EOF</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="n">sum</span> <span class="o">:=</span> <span class="m">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>行长度不定
输入数据有多组, 每行表示一组输入数据。</li>
</ol>

<p>每行不定有n个整数，空格隔开。(1 &lt;= n &lt;= 100)。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"bufio"</span>
    <span class="s">"fmt"</span>
    <span class="s">"os"</span>
    <span class="s">"strconv"</span>
    <span class="s">"strings"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 获取输入</span>
    <span class="n">inputs</span> <span class="o">:=</span> <span class="n">bufio</span><span class="o">.</span><span class="n">NewScanner</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdin</span><span class="p">)</span>
    <span class="c">// 循环直到读取到EOF</span>
    <span class="k">for</span> <span class="n">inputs</span><span class="o">.</span><span class="n">Scan</span><span class="p">()</span> <span class="p">{</span>  <span class="c">//每次读入一行</span>
        <span class="n">data</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">Text</span><span class="p">(),</span> <span class="s">" "</span><span class="p">)</span>  <span class="c">//通过空格将他们分割，并存入一个字符串切片</span>
        <span class="k">var</span> <span class="n">sum</span> <span class="kt">int</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>   <span class="c">//将字符串转换为int</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>数据</li>
</ol>

<p>输入有两行，第一行n</p>

<p>第二行是n个字符串，字符串之间用空格隔开</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span><span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"os"</span>
    <span class="s">"bufio"</span>
    <span class="s">"sort"</span>
    <span class="s">"strings"</span>
<span class="p">)</span>
 
<span class="k">func</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">in</span> <span class="o">:=</span> <span class="n">bufio</span><span class="o">.</span><span class="n">NewScanner</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdin</span><span class="p">)</span>
    <span class="n">in</span><span class="o">.</span><span class="n">Scan</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">in</span><span class="o">.</span><span class="n">Scan</span><span class="p">(){</span>
        <span class="n">str</span> <span class="o">:=</span> <span class="n">in</span><span class="o">.</span><span class="n">Text</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">" "</span><span class="p">)</span>
        <span class="n">sort</span><span class="o">.</span><span class="n">Strings</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c">//排序</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">strings</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">" "</span><span class="p">))</span>  <span class="c">//将切片连接成字符串</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>参考：<a href="https://www.cnblogs.com/yinzhengjie2020/p/12245290.html">Golang的标准输入输出</a>;<a href="https://zhuanlan.zhihu.com/p/551393704">Go语言标准输入输出处理</a>;<a href="https://juejin.cn/post/6844903954942263304">GoLang 的 bufio.NewScanner 按行读取文件的坑</a>
</li>
</ul>


                <hr style="visibility: hidden;">

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2023/04/11/virtualization_engineer_router/" data-toggle="tooltip" data-placement="top" title="虚拟化工程师之路">
                        Previous<br>
                        <span>虚拟化工程师之路</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2023/05/05/openstack_learn/" data-toggle="tooltip" data-placement="top" title="openstack学习">
                        Next<br>
                        <span>openstack学习</span>
                        </a>
                    </li>
                    
                </ul>


                <!--Gitalk评论start  -->
                
                <!-- 引入Gitalk评论插件  -->
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
                <div id="gitalk-container"></div>
                <!-- 引入一个生产md5的js，用于对id值进行处理，防止其过长 -->
                <!-- Thank DF:https://github.com/NSDingFan/NSDingFan.github.io/issues/3#issuecomment-407496538 -->
                <script src="/js/md5.min.js"></script>
                <script type="text/javascript">
                    var gitalk = new Gitalk({
                    clientID: '0224d5b04da044c201d4',
                    clientSecret: 'ccd26d0c1d8d4cc3377be7cb388f854ad2b4e5d0',
                    repo: 'wangpengcheng.github.io',
                    owner: 'wangpengcheng',
                    admin: ['wangpengcheng'],
                    distractionFreeMode: true,
                    id: md5(location.pathname),
                    });
                    gitalk.render('gitalk-container');
                </script>
                
                <!-- Gitalk end -->

                

            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#C++" title="C++" rel="37">
                                    C++
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B" title="基础编程" rel="24">
                                    基础编程
                                </a>
                            
        				
                            
                				<a href="/tags/#C/C++" title="C/C++" rel="26">
                                    C/C++
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91" title="后台开发" rel="12">
                                    后台开发
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#C" title="C" rel="4">
                                    C
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B" title="网络编程" rel="8">
                                    网络编程
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#STL%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" title="STL源码解析" rel="4">
                                    STL源码解析
                                </a>
                            
        				
                            
                				<a href="/tags/#Linux" title="Linux" rel="18">
                                    Linux
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" title="操作系统" rel="12">
                                    操作系统
                                </a>
                            
        				
                            
                				<a href="/tags/#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" title="程序设计" rel="14">
                                    程序设计
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#%E4%BC%98%E5%8C%96" title="优化" rel="4">
                                    优化
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#UML" title="UML" rel="4">
                                    UML
                                </a>
                            
        				
                            
                				<a href="/tags/#UNIX" title="UNIX" rel="5">
                                    UNIX
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" title="学习笔记" rel="14">
                                    学习笔记
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#%E9%9D%A2%E8%AF%95" title="面试" rel="12">
                                    面试
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Java" title="Java" rel="11">
                                    Java
                                </a>
                            
        				
                            
                				<a href="/tags/#%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" title="读书笔记" rel="6">
                                    读书笔记
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#%E4%B8%AD%E9%97%B4%E4%BB%B6" title="中间件" rel="5">
                                    中间件
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#go" title="go" rel="4">
                                    go
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0" title="阅读笔记" rel="5">
                                    阅读笔记
                                </a>
                            
        				
                            
                				<a href="/tags/#KVM" title="KVM" rel="4">
                                    KVM
                                </a>
                            
        				
                            
                				<a href="/tags/#QEMU" title="QEMU" rel="4">
                                    QEMU
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#%E8%99%9A%E6%8B%9F%E5%8C%96" title="虚拟化" rel="5">
                                    虚拟化
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://zhengwuyang.com">WY</a></li>
                    
                        <li><a href="http://www.jianshu.com/u/e71990ada2fd">简书·JF</a></li>
                    
                        <li><a href="https://apple.com">Apple</a></li>
                    
                        <li><a href="https://developer.apple.com/">Apple Developer</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        // BY Fix:去除标题前的‘#’ issues:<https://github.com/qiubaiying/qiubaiying.github.io/issues/137>
        // anchors.options = {
        //   visible: 'always',
        //   placement: 'right',
        //   icon: '#'
        // };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <!-- add jianshu add target = "_blank" to <a> by BY -->
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    


                    
                    <li>
                        <a target="_blank" href="https://www.facebook.com/wangpengcheng">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/wangpengcheng">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright © My Blog 2024
                    <br>
                    Theme on <a href="https://github.com/wangpengcheng/wangpengcheng.github.io.git">GitHub</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px" height="20px" src="https://ghbtns.com/github-btn.html?user=wangpengcheng&repo=wangpengcheng.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>

<!-- Service Worker -->

<script type="text/javascript">
    if(navigator.serviceWorker){
        // For security reasons, a service worker can only control the pages that are in the same directory level or below it. That's why we put sw.js at ROOT level.
        navigator.serviceWorker
            .register('/sw.js')
            .then((registration) => {console.log('Service Worker Registered. ', registration)})
            .catch((error) => {console.log('ServiceWorker registration failed: ', error)})
    }
</script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/ 
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers   
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '4b4b33b70559d548603afcd03258bacb';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>







<!-- Image to hack wechat -->
<img src="/img/apple-touch-icon.png" width="0" height="0">
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
